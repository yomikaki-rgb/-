<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>語いクイズ</title>
  <style>
    :root {
      --bg1:#eef2ff;
      --bg2:#f3e8ff;
      --card:#ffffffcc;
      --ink:#111827;
      --ink-sub:#4b5563;
      --primary:#4f46e5;
      --primary-soft:#e0e7ff;
      --correct:#16a34a;
      --wrong:#dc2626;
      --border:#d1d5db;
    }
    * { box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    body {
      margin:0;
      min-height:100vh;
      padding:16px;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",
        "Hiragino Kaku Gothic ProN","ヒラギノ角ゴ ProN","Yu Gothic","メイリオ",sans-serif;
      background:linear-gradient(135deg,var(--bg1),var(--bg2));
      display:flex;
      justify-content:center;
      align-items:center;
    }

    /* ★オンライン用シェル（既存UIは変更しない：外側に右パネルを追加） */
    .shell{
      width:100%;
      max-width:980px;
      display:flex;
      gap:14px;
      align-items:stretch;
      justify-content:center;
    }
    @media (max-width:860px){
      .shell{ flex-direction:column; max-width:700px; }
    }

    .app {
      width:100%;
      max-width:700px;
      background:var(--card);
      border-radius:18px;
      padding:20px 18px 18px;
      box-shadow:0 20px 40px rgba(15,23,42,0.25);
    }
    .app-title {
      font-size:1.4rem;
      font-weight:700;
      text-align:center;
      margin-bottom:8px;
      color:var(--ink);
    }
    .status-row {
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:0.9rem;
      color:var(--ink-sub);
      margin-bottom:10px;
      gap:10px;
    }
    .status-row .subnote{ font-size:0.85rem; opacity:0.85; white-space:nowrap; }

    .progress-bar {
      width:100%;
      height:8px;
      background:#e5e7eb;
      border-radius:999px;
      overflow:hidden;
      margin-bottom:16px;
    }
    .progress-fill {
      height:100%;
      width:0%;
      background:var(--primary);
      transition:width 0.25s ease-out;
    }
    .card {
      background:white;
      border-radius:16px;
      border:1px solid var(--border);
      padding:16px;
    }
    .question-text {
      font-size:1.15rem;
      line-height:1.6;
      margin-bottom:14px;
      color:var(--ink);
    }
    .hint {
      font-size:0.85rem;
      color:var(--ink-sub);
      margin-bottom:10px;
    }
    .choices {
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-bottom:10px;
    }
    .choice-btn {
      border:1px solid var(--border);
      border-radius:999px;
      padding:8px 14px;
      font-size:1rem;
      text-align:left;
      background:#f9fafb;
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      transition:transform 0.05s ease, box-shadow 0.05s ease, background 0.15s;
    }
    .choice-btn span.label { flex:1; }
    .choice-btn span.mark { font-size:0.8rem; opacity:0.7; }
    .choice-btn:active {
      transform:scale(0.98);
      box-shadow:0 2px 4px rgba(15,23,42,0.12);
    }
    .choice-btn.disabled { cursor:default; opacity:0.85; }
    .choice-btn.correct {
      border-color:var(--correct);
      background:#ecfdf3;
      color:var(--correct);
      font-weight:600;
    }
    .choice-btn.wrong {
      border-color:var(--wrong);
      background:#fef2f2;
      color:var(--wrong);
      font-weight:600;
    }
    .feedback { min-height:1.6em; font-size:0.95rem; margin-top:4px; }
    .feedback.correct { color:var(--correct); }
    .feedback.wrong { color:var(--wrong); }

    .nav-row {
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:12px;
      gap:8px;
    }
    .score-text { font-size:0.9rem; color:var(--ink-sub); }
    .next-btn {
      border:none;
      border-radius:999px;
      background:var(--primary);
      color:white;
      font-size:0.95rem;
      font-weight:600;
      padding:8px 18px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:4px;
      box-shadow:0 6px 14px rgba(79,70,229,0.35);
      transition:transform 0.05s ease, box-shadow 0.05s ease, opacity 0.15s;
      white-space:nowrap;
    }
    .next-btn:active {
      transform:translateY(1px);
      box-shadow:0 3px 8px rgba(79,70,229,0.4);
    }
    .next-btn.disabled {
      opacity:0.4;
      cursor:default;
      box-shadow:none;
      transform:none;
    }

    .roulette { margin-top:14px; text-align:center; }
    .roulette-label { font-size:0.9rem; color:var(--ink-sub); margin-bottom:4px; }
    .roulette-wheel {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:72px;
      height:72px;
      border-radius:999px;
      border:2px solid var(--primary);
      font-size:1.4rem;
      font-weight:700;
      background:#ffffff;
      box-shadow:0 6px 14px rgba(79,70,229,0.25);
      cursor:pointer;
      user-select:none;
    }
    .roulette-wheel.disabled { opacity:0.4; cursor:default; }

    .card-container {
      margin-top:8px;
      display:none;
      justify-content:center;
      gap:10px;
    }
    .card-option {
      width:60px;
      height:80px;
      border-radius:10px;
      border:2px solid var(--primary);
      background:linear-gradient(135deg,#e5e7eb,#d1d5db);
      box-shadow:0 4px 8px rgba(15,23,42,0.15);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.3rem;
      font-weight:700;
      cursor:pointer;
      transition:transform 0.1s ease, box-shadow 0.1s ease, background 0.15s, border-color 0.15s;
      user-select:none;
    }
    .card-option:active { transform:translateY(1px); box-shadow:0 2px 4px rgba(15,23,42,0.2); }
    .card-option.disabled { opacity:0.6; cursor:default; box-shadow:none; }
    .card-option.selected { background:#ffffff; border-color:var(--correct); }

    .result { text-align:center; margin-top:8px; font-size:1rem; }
    .restart-btn {
      margin-top:10px;
      border-radius:999px;
      border:1px solid var(--primary);
      background:white;
      color:var(--primary);
      font-weight:600;
      font-size:0.95rem;
      padding:8px 16px;
      cursor:pointer;
    }

    ruby rt { font-size:0.6em; }

    @media (max-width:480px) {
      .app { padding:16px 12px 14px; }
      .question-text { font-size:1.05rem; }
      .choice-btn { padding:8px 10px; font-size:0.95rem; }
      .roulette-wheel { width:64px; height:64px; font-size:1.2rem; }
      .card-option { width:52px; height:72px; font-size:1.1rem; }
    }

    /* ★右パネル（必須UI） */
    .side{
      width:260px;
      min-width:240px;
      background:rgba(255,255,255,0.65);
      border:1px solid rgba(209,213,219,0.9);
      border-radius:18px;
      box-shadow:0 12px 26px rgba(15,23,42,0.12);
      padding:14px 12px;
      color:var(--ink);
      font-size:0.9rem;
    }
    @media (max-width:860px){
      .side{ width:100%; min-width:0; }
    }
    .side h3{
      margin:2px 0 8px;
      font-size:0.95rem;
      font-weight:700;
    }
    .side .row{ display:flex; gap:8px; align-items:center; margin:6px 0; }
    .side input{
      width:100%;
      padding:8px 10px;
      border:1px solid var(--border);
      border-radius:10px;
      font-size:0.95rem;
      outline:none;
      background:white;
    }
    .side button{
      border:none;
      border-radius:12px;
      background:var(--primary);
      color:white;
      padding:8px 12px;
      font-weight:700;
      cursor:pointer;
      white-space:nowrap;
      box-shadow:0 6px 14px rgba(79,70,229,0.25);
    }
    .side button.secondary{
      background:white;
      color:var(--primary);
      border:1px solid var(--primary);
      box-shadow:none;
    }
    .side button.disabled{
      opacity:0.5;
      cursor:default;
      box-shadow:none;
    }
    .side .hint{
      margin:6px 0 0;
      font-size:0.8rem;
      color:var(--ink-sub);
    }
    .side .urls input{
      font-size:0.85rem;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(209,213,219,0.95);
      background:rgba(255,255,255,0.75);
      color:var(--ink-sub);
      font-size:0.82rem;
      white-space:nowrap;
    }
    .onlineDot{
      width:8px; height:8px; border-radius:999px;
      background:#9ca3af;
      display:inline-block;
    }
    .onlineDot.on{ background:#22c55e; }
    .onlineDot.off{ background:#ef4444; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="app">
      <div class="app-title">語いクイズ</div>

      <div class="status-row">
        <div>もんだい <span id="qNumber">1</span> / <span id="qTotal">0</span></div>
        <div class="subnote" id="turnNote"></div>
      </div>

      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>

      <div class="card">
        <div class="question-text" id="questionText"></div>
        <div class="hint" id="questionHint"></div>

        <div class="choices" id="choicesContainer"></div>

        <div class="feedback" id="feedback"></div>

        <div class="nav-row">
          <div class="score-text" id="scoreText">せいかい：0 もん</div>
          <button class="next-btn disabled" id="nextBtn" type="button">
            こたえを えらんでね
          </button>
        </div>
      </div>

      <div class="roulette">
        <div class="roulette-label">せいかいしたら しかけが でるよ</div>
        <div class="roulette-wheel disabled" id="rouletteWheel">？</div>
        <div class="card-container" id="cardContainer"></div>
      </div>

      <div class="result" id="resultArea"></div>
    </div>

    <!-- ★必須：右側UI -->
    <aside class="side" aria-label="オンライン設定">
      <h3>オンライン設定</h3>
      <div class="row">
        <span class="badge"><span id="onlineDot" class="onlineDot off"></span><span id="onlineLabel">オフライン</span></span>
      </div>

      <div class="row">
        <input id="roomInput" placeholder="部屋番号（例: class1）" />
        <button id="makeRoomUrlBtn" type="button">URL作成</button>
      </div>

      <div class="urls">
        <div class="hint">プレイヤー1用URL</div>
        <div class="row"><input id="urlP1" readonly /></div>
        <div class="hint">プレイヤー2用URL</div>
        <div class="row"><input id="urlP2" readonly /></div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="startBtn" type="button">スタート</button>
        <button id="resetBtn" type="button" class="secondary">リセット</button>
      </div>
      <div class="hint" id="onlineHint">
        URLに <b>?room=部屋名&amp;me=1</b> / <b>?room=部屋名&amp;me=2</b> を付けるとオンライン同期します。<br>
        （接続に失敗した場合は自動的にオフライン動作に戻ります）
      </div>
    </aside>
  </div>

  <script type="module">
    // ============================
    // ★オンライン対戦：Firebase Realtime Database（URLパラメータ方式）
    //  - ?room=部屋名&me=1 / ?room=部屋名&me=2
    //  - 失敗時はオフラインのまま動作
    // ============================

    // --- Firebase設定（指定どおり埋め込み） ---
    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
    const firebaseConfig = {
      apiKey: "AIzaSyBtKWi2tXanWuDf_Du5C9tr5ZwOAfNBRIs",
      authDomain: "goi-battle-g3.firebaseapp.com",
      projectId: "goi-battle-g3",
      storageBucket: "goi-battle-g3.firebasestorage.app",
      messagingSenderId: "1052102588017",
      appId: "1:1052102588017:web:e8a09649466f4504f08dd0",
      measurementId: "G-Y7TQVZ2R2V"
    };

    // --- Firebase modular SDK ---

    // ★Firebase SDKは動的に読み込む（CDNブロック/オフラインでもアプリが落ちないように）
    let FB = null;
    async function loadFirebase(){
      if(FB) return FB;
      const appMod = await import("https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js");
      const dbMod  = await import("https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js");
      FB = {
        initializeApp: appMod.initializeApp,
        getDatabase: dbMod.getDatabase,
        ref: dbMod.ref,
        set: dbMod.set,
        update: dbMod.update,
        onValue: dbMod.onValue,
        onChildAdded: dbMod.onChildAdded,
        push: dbMod.push,
        serverTimestamp: dbMod.serverTimestamp,
        get: dbMod.get,
        child: dbMod.child
      };
      return FB;
    }

    // --- URLパラメータ ---
    const params = new URLSearchParams(location.search);
    const ROOM = (params.get("room") || "").trim();
    const ME = Number(params.get("me") || "0"); // 1 or 2

    const ONLINE = {
      enabled: false,
      room: ROOM,
      me: (ME === 1 || ME === 2) ? ME : 0,
      app: null,
      db: null,
      suppress: false,   // 受信適用中の送信抑制
      lastActionKey: "", // child_added の重複防止
      ready: false
    };

    // ============================
    // オフライン版：ここから下は「見た目・操作仕様」を変えず
    // “入力→状態” をオンライン時のみ action 同期する
    // ============================

    // 📚 ルビ入り語いクイズ（①〜㊺）※見出し語は問題文の冒頭に出さない
    const questions = [
      {
        // ① 高熱
        text: `<ruby>朝<rt>あさ</rt></ruby>から<ruby>体<rt>からだ</rt></ruby>がとてもあつく、<ruby>頭<rt>あたま</rt></ruby>がぼーっとして<ruby>立<rt>た</rt></ruby>ち<ruby>上<rt>あ</rt></ruby>がるのもつらい<ruby>状態<rt>じょうたい</rt></ruby>です。<ruby>体温計<rt>たいおんけい</rt></ruby>で<ruby>測<rt>はか</rt></ruby>ると、38<ruby>度<rt>ど</rt></ruby>をこえていました。この<ruby>体<rt>からだ</rt></ruby>のようすを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>発汗<rt>はっかん</rt></ruby>`,
          `<ruby>高熱<rt>こうねつ</rt></ruby>`,
          `<ruby>冷<rt>ひ</rt></ruby>え`
        ],
        correctIndex: 1
      },
      {
        // ② 都道府県
        text: `<ruby>日本<rt>にほん</rt></ruby>の<ruby>地図<rt>ちず</rt></ruby>を<ruby>見<rt>み</rt></ruby>ると、<ruby>全国<rt>ぜんこく</rt></ruby>がいくつもの<ruby>区切<rt>くぎ</rt></ruby>られた<ruby>場所<rt>ばしょ</rt></ruby>に<ruby>分<rt>わ</rt></ruby>かれています。<ruby>群馬<rt>ぐんま</rt></ruby>や<ruby>奈良<rt>なら</rt></ruby>のように、<ruby>日本<rt>にほん</rt></ruby>の<ruby>中<rt>なか</rt></ruby>の<ruby>大<rt>おお</rt></ruby>きな<ruby>地域<rt>ちいき</rt></ruby>の<ruby>区分<rt>くぶん</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>市町村<rt>しちょうそん</rt></ruby>`,
          `<ruby>地方<rt>ちほう</rt></ruby>`,
          `<ruby>都道府県<rt>とどうふけん</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ③ 児童生徒
        text: `<ruby>小学校<rt>しょうがっこう</rt></ruby>や<ruby>中学校<rt>ちゅうがっこう</rt></ruby>で、<ruby>毎日<rt>まいにち</rt></ruby><ruby>勉強<rt>べんきょう</rt></ruby>や<ruby>生活<rt>せいかつ</rt></ruby>をしている<ruby>子<rt>こ</rt></ruby>どもたちをまとめて<ruby>表<rt>あらわ</rt></ruby>すとき、どの<ruby>言<rt>い</rt></ruby>い<ruby>方<rt>かた</rt></ruby>がいちばん<ruby>合<rt>あ</rt></ruby>っているでしょう。`,
        choices: [
          `<ruby>学年<rt>がくねん</rt></ruby>`,
          `<ruby>児童生徒<rt>じどうせいと</rt></ruby>`,
          `<ruby>先生方<rt>せんせいがた</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ④ 関係
        text: `クラスの<ruby>友<rt>とも</rt></ruby>だちと、けんかをしたり<ruby>仲<rt>なか</rt></ruby>よくしたりしながら、つながりをもって<ruby>生活<rt>せいかつ</rt></ruby>しています。<ruby>人<rt>ひと</rt></ruby>と<ruby>人<rt>ひと</rt></ruby>とのつながりを<ruby>表<rt>あらわ</rt></ruby>す<ruby>言葉<rt>ことば</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>友達<rt>ともだち</rt></ruby>`,
          `<ruby>関係<rt>かんけい</rt></ruby>`,
          `<ruby>会話<rt>かいわ</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑤ 漢字辞典
        text: `<ruby>知<rt>し</rt></ruby>らない<ruby>漢字<rt>かんじ</rt></ruby>の<ruby>読<rt>よ</rt></ruby>み<ruby>方<rt>かた</rt></ruby>や<ruby>意味<rt>いみ</rt></ruby>、<ruby>画数<rt>かくすう</rt></ruby>などを<ruby>調<rt>しら</rt></ruby>べたいときに<ruby>使<rt>つか</rt></ruby>う<ruby>本<rt>ほん</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>図鑑<rt>ずかん</rt></ruby>`,
          `<ruby>漢字辞典<rt>かんじじてん</rt></ruby>`,
          `<ruby>物語集<rt>ものがたりしゅう</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑥ 国語辞典
        text: `ある<ruby>言葉<rt>ことば</rt></ruby>の<ruby>意味<rt>いみ</rt></ruby>や<ruby>使<rt>つか</rt></ruby>い<ruby>方<rt>かた</rt></ruby>をくわしく<ruby>調<rt>しら</rt></ruby>べたいときに<ruby>使<rt>つか</rt></ruby>う、<ruby>本<rt>ほん</rt></ruby>の<ruby>種類<rt>しゅるい</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>国語辞典<rt>こくごじてん</rt></ruby>`,
          `<ruby>地図帳<rt>ちずちょう</rt></ruby>`,
          `<ruby>問題集<rt>もんだいしゅう</rt></ruby>`
        ],
        correctIndex: 0
      },
      {
        // ⑦ 成人式
        text: `20<ruby>歳<rt>さい</rt></ruby>になる<ruby>人<rt>ひと</rt></ruby>たちが<ruby>集<rt>あつ</rt></ruby>まって、<ruby>大人<rt>おとな</rt></ruby>になったお<ruby>祝<rt>いわ</rt></ruby>いをする<ruby>行事<rt>ぎょうじ</rt></ruby>があります。この<ruby>行事<rt>ぎょうじ</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>文化祭<rt>ぶんかさい</rt></ruby>`,
          `<ruby>卒業式<rt>そつぎょうしき</rt></ruby>`,
          `<ruby>成人式<rt>せいじんしき</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ⑧ 訓練
        text: `<ruby>火事<rt>かじ</rt></ruby>や<ruby>地震<rt>じしん</rt></ruby>にそなえて、<ruby>学校<rt>がっこう</rt></ruby>でにげる<ruby>練習<rt>れんしゅう</rt></ruby>をくり<ruby>返<rt>かえ</rt></ruby>し<ruby>行<rt>おこな</rt></ruby>います。このように、<ruby>本番<rt>ほんばん</rt></ruby>にそなえて<ruby>練習<rt>れんしゅう</rt></ruby>することを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>訓練<rt>くんれん</rt></ruby>`,
          `<ruby>試合<rt>しあい</rt></ruby>`,
          `<ruby>発表<rt>はっぴょう</rt></ruby>`
        ],
        correctIndex: 0
      },
      {
        // ⑨ 人類
        text: `<ruby>大昔<rt>おおむかし</rt></ruby>から<ruby>現在<rt>げんざい</rt></ruby>まで、<ruby>地球<rt>ちきゅう</rt></ruby>で<ruby>生<rt>い</rt></ruby>きてきたすべての<ruby>人間<rt>にんげん</rt></ruby>の<ruby>仲間<rt>なかま</rt></ruby>をまとめて<ruby>表<rt>あらわ</rt></ruby>す<ruby>言葉<rt>ことば</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>生物<rt>せいぶつ</rt></ruby>`,
          `<ruby>人類<rt>じんるい</rt></ruby>`,
          `<ruby>動物<rt>どうぶつ</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑩ 順番
        text: `ならんで<ruby>歩<rt>ある</rt></ruby>くときに、<ruby>前<rt>まえ</rt></ruby>の<ruby>人<rt>ひと</rt></ruby>の<ruby>次<rt>つぎ</rt></ruby>に<ruby>自分<rt>じぶん</rt></ruby>が<ruby>入<rt>はい</rt></ruby>るなど、<ruby>決<rt>き</rt></ruby>められたならび<ruby>方<rt>かた</rt></ruby>があります。このならびの<ruby>決<rt>き</rt></ruby>まりを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>列<rt>れつ</rt></ruby>`,
          `<ruby>順番<rt>じゅんばん</rt></ruby>`,
          `<ruby>方向<rt>ほうこう</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑪ 愛情
        text: `<ruby>家族<rt>かぞく</rt></ruby>が<ruby>病気<rt>びょうき</rt></ruby>のときに<ruby>心配<rt>しんぱい</rt></ruby>して<ruby>世話<rt>せわ</rt></ruby>をしたり、<ruby>相手<rt>あいて</rt></ruby>のことを<ruby>思<rt>おも</rt></ruby>って<ruby>行動<rt>こうどう</rt></ruby>したりする<ruby>気持<rt>きも</rt></ruby>ちを<ruby>表<rt>あらわ</rt></ruby>す<ruby>言葉<rt>ことば</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>表情<rt>ひょうじょう</rt></ruby>`,
          `<ruby>愛情<rt>あいじょう</rt></ruby>`,
          `<ruby>感心<rt>かんしん</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑫ 昨年
        text: `<ruby>今年<rt>ことし</rt></ruby>の<ruby>前<rt>まえ</rt></ruby>の<ruby>年<rt>とし</rt></ruby>のことを<ruby>話<rt>はな</rt></ruby>すときに<ruby>使<rt>つか</rt></ruby>う<ruby>言葉<rt>ことば</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>先月<rt>せんげつ</rt></ruby>`,
          `<ruby>昨年<rt>さくねん</rt></ruby>`,
          `<ruby>明日<rt>あした</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑬ 城下町
        text: `<ruby>昔<rt>むかし</rt></ruby>、お<ruby>城<rt>しろ</rt></ruby>のまわりには、<ruby>家<rt>いえ</rt></ruby>や<ruby>店<rt>みせ</rt></ruby>が<ruby>集<rt>あつ</rt></ruby>まってつくられた<ruby>町<rt>まち</rt></ruby>がありました。こうした<ruby>町<rt>まち</rt></ruby>の<ruby>呼<rt>よ</rt></ruby>び<ruby>方<rt>かた</rt></ruby>としていちばん<ruby>合<rt>あ</rt></ruby>っているものはどれでしょう。`,
        choices: [
          `<ruby>農村<rt>のうそん</rt></ruby>`,
          `<ruby>城下町<rt>じょうかまち</rt></ruby>`,
          `<ruby>港町<rt>みなとまち</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑭ 伝説
        text: `<ruby>昔<rt>むかし</rt></ruby>から<ruby>語<rt>かた</rt></ruby>りつがれてきたふしぎな<ruby>話<rt>はなし</rt></ruby>で、<ruby>本当<rt>ほんとう</rt></ruby>かどうか<ruby>分<rt>わ</rt></ruby>からない<ruby>物語<rt>ものがたり</rt></ruby>のような<ruby>話<rt>はなし</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>記録<rt>きろく</rt></ruby>`,
          `<ruby>伝説<rt>でんせつ</rt></ruby>`,
          `<ruby>事実<rt>じじつ</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑮ 説明
        text: `<ruby>分<rt>わ</rt></ruby>からないことを、<ruby>相手<rt>あいて</rt></ruby>に<ruby>分<rt>わ</rt></ruby>かるように<ruby>言葉<rt>ことば</rt></ruby>で<ruby>伝<rt>つた</rt></ruby>えることを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>説明<rt>せつめい</rt></ruby>`,
          `<ruby>相談<rt>そうだん</rt></ruby>`,
          `<ruby>指示<rt>しじ</rt></ruby>`
        ],
        correctIndex: 0
      },
      {
        // ⑯ 好物
        text: `その<ruby>人<rt>ひと</rt></ruby>がとくに<ruby>好<rt>す</rt></ruby>きで、<ruby>進<rt>すす</rt></ruby>んで<ruby>食<rt>た</rt></ruby>べたがる<ruby>食<rt>た</rt></ruby>べ<ruby>物<rt>もの</rt></ruby>のことを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>名物<rt>めいぶつ</rt></ruby>`,
          `<ruby>好物<rt>こうぶつ</rt></ruby>`,
          `<ruby>食品<rt>しょくひん</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑰ 印刷
        text: `<ruby>紙<rt>かみ</rt></ruby>に<ruby>文字<rt>もじ</rt></ruby>や<ruby>絵<rt>え</rt></ruby>を、<ruby>機械<rt>きかい</rt></ruby>を<ruby>使<rt>つか</rt></ruby>ってたくさんおなじようにうつし<ruby>取<rt>と</rt></ruby>る<ruby>作業<rt>さぎょう</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>文書<rt>ぶんしょ</rt></ruby>`,
          `<ruby>印刷<rt>いんさつ</rt></ruby>`,
          `<ruby>作成<rt>さくせい</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑱ 要求
        text: `してほしいことや、のぞんでいることを<ruby>相手<rt>あいて</rt></ruby>に<ruby>強<rt>つよ</rt></ruby>く<ruby>伝<rt>つた</rt></ruby>えるときの<ruby>言<rt>い</rt></ruby>い<ruby>方<rt>かた</rt></ruby>として<ruby>合<rt>あ</rt></ruby>っているものはどれでしょう。`,
        choices: [
          `<ruby>感想<rt>かんそう</rt></ruby>`,
          `<ruby>要求<rt>ようきゅう</rt></ruby>`,
          `<ruby>反省<rt>はんせい</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ⑲ 目的
        text: `<ruby>遠足<rt>えんそく</rt></ruby>に<ruby>行<rt>い</rt></ruby>く<ruby>理由<rt>りゆう</rt></ruby>が「みんなで<ruby>自然<rt>しぜん</rt></ruby>を<ruby>学<rt>まな</rt></ruby>ぶため」のように、<ruby>行動<rt>こうどう</rt></ruby>をするもとになるねらいのことを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>予定<rt>よてい</rt></ruby>`,
          `<ruby>理由<rt>りゆう</rt></ruby>`,
          `<ruby>目的<rt>もくてき</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ⑳ 必要
        text: `なくてはならないものや、どうしてもいるものを<ruby>表<rt>あらわ</rt></ruby>す<ruby>言葉<rt>ことば</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>便利<rt>べんり</rt></ruby>`,
          `<ruby>大切<rt>たいせつ</rt></ruby>`,
          `<ruby>必要<rt>ひつよう</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ㉑ 最初
        text: `かけっこでスタートの<ruby>合図<rt>あいず</rt></ruby>が<ruby>鳴<rt>な</rt></ruby>ったとき、いちばん<ruby>先<rt>さき</rt></ruby>に<ruby>走<rt>はし</rt></ruby>り<ruby>出<rt>だ</rt></ruby>す<ruby>位置<rt>いち</rt></ruby>や、いちばんはじめのことを<ruby>表<rt>あらわ</rt></ruby>す<ruby>言葉<rt>ことば</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>途中<rt>とちゅう</rt></ruby>`,
          `<ruby>最初<rt>さいしょ</rt></ruby>`,
          `<ruby>最後<rt>さいご</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㉒ 案内
        text: `<ruby>駅<rt>えき</rt></ruby>で<ruby>道<rt>みち</rt></ruby>が<ruby>分<rt>わ</rt></ruby>からない<ruby>人<rt>ひと</rt></ruby>に、<ruby>行<rt>い</rt></ruby>き<ruby>先<rt>さき</rt></ruby>までの<ruby>道<rt>みち</rt></ruby>をおしえてあげるような<ruby>行動<rt>こうどう</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>案内<rt>あんない</rt></ruby>`,
          `<ruby>提出<rt>ていしゅつ</rt></ruby>`,
          `<ruby>指導<rt>しどう</rt></ruby>`
        ],
        correctIndex: 0
      },
      {
        // ㉓ 商店街
        text: `<ruby>野菜屋<rt>やさいや</rt></ruby>さんやおかし<ruby>屋<rt>や</rt></ruby>さん、<ruby>文房具店<rt>ぶんぼうぐてん</rt></ruby>など、たくさんの<ruby>店<rt>みせ</rt></ruby>が<ruby>道<rt>みち</rt></ruby>の<ruby>両側<rt>りょうがわ</rt></ruby>にならんでいる<ruby>場所<rt>ばしょ</rt></ruby>があります。このような<ruby>場所<rt>ばしょ</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>住宅地<rt>じゅうたくち</rt></ruby>`,
          `<ruby>商店街<rt>しょうてんがい</rt></ruby>`,
          `<ruby>工業地<rt>こうぎょうち</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㉔ 試験
        text: `<ruby>学<rt>まな</rt></ruby>んだことがどれくらい<ruby>身<rt>み</rt></ruby>についているかをたしかめるために、<ruby>学校<rt>がっこう</rt></ruby>で<ruby>問題<rt>もんだい</rt></ruby>を<ruby>解<rt>と</rt></ruby>く<ruby>時間<rt>じかん</rt></ruby>があります。このようなとりくみを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>練習<rt>れんしゅう</rt></ruby>`,
          `<ruby>発表<rt>はっぴょう</rt></ruby>`,
          `<ruby>試験<rt>しけん</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ㉕ 選挙
        text: `クラスの<ruby>代表<rt>だいひょう</rt></ruby>や<ruby>市<rt>し</rt></ruby>のリーダーなどを<ruby>決<rt>き</rt></ruby>めるとき、みんなが<ruby>投票<rt>とうひょう</rt></ruby>して<ruby>選<rt>えら</rt></ruby>ぶ<ruby>方法<rt>ほうほう</rt></ruby>があります。この<ruby>決<rt>き</rt></ruby>め<ruby>方<rt>かた</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>相談<rt>そうだん</rt></ruby>`,
          `<ruby>選挙<rt>せんきょ</rt></ruby>`,
          `<ruby>指名<rt>しめい</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㉖ 観客
        text: `サッカーやコンサートで、プレーや<ruby>演奏<rt>えんそう</rt></ruby>を<ruby>見<rt>み</rt></ruby>ておうえんしている<ruby>人<rt>ひと</rt></ruby>たちをまとめて<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>出場者<rt>しゅつじょうしゃ</rt></ruby>`,
          `<ruby>係員<rt>かかりいん</rt></ruby>`,
          `<ruby>観客<rt>かんきゃく</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ㉗ 静電気
        text: `ドアノブにさわったときに「パチッ」として、<ruby>指<rt>ゆび</rt></ruby>がしびれることがあります。このときに<ruby>起<rt>お</rt></ruby>きている<ruby>現象<rt>げんしょう</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>電流<rt>でんりゅう</rt></ruby>`,
          `<ruby>静電気<rt>せいでんき</rt></ruby>`,
          `<ruby>磁力<rt>じりょく</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㉘ 国旗
        text: `オリンピックなどで、その<ruby>国<rt>くに</rt></ruby>を<ruby>表<rt>あらわ</rt></ruby>すためにかかげられている<ruby>旗<rt>はた</rt></ruby>があります。この<ruby>旗<rt>はた</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>名札<rt>なふだ</rt></ruby>`,
          `<ruby>政治<rt>せいじ</rt></ruby>`,
          `<ruby>国旗<rt>こっき</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ㉙ 材料
        text: `カレーをつくるときの<ruby>肉<rt>にく</rt></ruby>や<ruby>野菜<rt>やさい</rt></ruby>のように、<ruby>料理<rt>りょうり</rt></ruby>や<ruby>工作<rt>こうさく</rt></ruby>のもとになるものを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>道具<rt>どうぐ</rt></ruby>`,
          `<ruby>材料<rt>ざいりょう</rt></ruby>`,
          `<ruby>作品<rt>さくひん</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㉚ 群馬県
        text: `<ruby>草津温泉<rt>くさつおんせん</rt></ruby>があり、<ruby>関東地方<rt>かんとうちほう</rt></ruby>の<ruby>内陸<rt>ないりく</rt></ruby>に<ruby>位置<rt>いち</rt></ruby>する<ruby>県<rt>けん</rt></ruby>の<ruby>名前<rt>なまえ</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>栃木県<rt>とちぎけん</rt></ruby>`,
          `<ruby>群馬県<rt>ぐんまけん</rt></ruby>`,
          `<ruby>長野県<rt>ながのけん</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㉛ 奈良県
        text: `<ruby>大仏<rt>だいぶつ</rt></ruby>があり、しかが<ruby>公園<rt>こうえん</rt></ruby>を<ruby>歩<rt>ある</rt></ruby>いていることで<ruby>知<rt>し</rt></ruby>られている<ruby>県<rt>けん</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>京都府<rt>きょうとふ</rt></ruby>`,
          `<ruby>奈良県<rt>ならけん</rt></ruby>`,
          `<ruby>三重県<rt>みえけん</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㉜ 豊富
        text: `<ruby>食<rt>た</rt></ruby>べ<ruby>物<rt>もの</rt></ruby>の<ruby>種類<rt>しゅるい</rt></ruby>が<ruby>多<rt>おお</rt></ruby>く、<ruby>選<rt>えら</rt></ruby>べるものがたくさんあるとき、そのようすを<ruby>表<rt>あらわ</rt></ruby>す<ruby>言葉<rt>ことば</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>不足<rt>ふそく</rt></ruby>`,
          `<ruby>豊富<rt>ほうふ</rt></ruby>`,
          `<ruby>単調<rt>たんちょう</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㉞ 岐阜県
        text: `<ruby>木曽川<rt>きそがわ</rt></ruby>や<ruby>長良川<rt>ながらがわ</rt></ruby>がながれ、<ruby>内陸<rt>ないりく</rt></ruby>に<ruby>位置<rt>いち</rt></ruby>する<ruby>中部地方<rt>ちゅうぶちほう</rt></ruby>の<ruby>県<rt>けん</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>岐阜県<rt>ぎふけん</rt></ruby>`,
          `<ruby>愛知県<rt>あいちけん</rt></ruby>`,
          `<ruby>三重県<rt>みえけん</rt></ruby>`
        ],
        correctIndex: 0
      },
      {
        // ㉟ 季節風
        text: `<ruby>冬<rt>ふゆ</rt></ruby>になると<ruby>日本海側<rt>にほんかいがわ</rt></ruby>に<ruby>冷<rt>つめ</rt></ruby>たいかぜがふき、<ruby>雪<rt>ゆき</rt></ruby>が<ruby>多<rt>おお</rt></ruby>くふります。このように、<ruby>季節<rt>きせつ</rt></ruby>ごとにふく<ruby>向<rt>む</rt></ruby>きが<ruby>変<rt>か</rt></ruby>わるかぜを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>台風<rt>たいふう</rt></ruby>`,
          `<ruby>季節風<rt>きせつふう</rt></ruby>`,
          `<ruby>つむじ風<rt>つむじかぜ</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㊱ 季節
        text: `<ruby>一年<rt>いちねん</rt></ruby>の<ruby>中<rt>なか</rt></ruby>で、<ruby>春<rt>はる</rt></ruby>・<ruby>夏<rt>なつ</rt></ruby>・<ruby>秋<rt>あき</rt></ruby>・<ruby>冬<rt>ふゆ</rt></ruby>のように、<ruby>気温<rt>きおん</rt></ruby>や<ruby>自然<rt>しぜん</rt></ruby>のようすが<ruby>変<rt>か</rt></ruby>わっていくまとまりを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>天候<rt>てんこう</rt></ruby>`,
          `<ruby>月日<rt>つきひ</rt></ruby>`,
          `<ruby>季節<rt>きせつ</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ㊲ 特別
        text: `いつもとはちがって、とくに<ruby>大切<rt>たいせつ</rt></ruby>にされたり、めずらしかったりするようすを<ruby>表<rt>あらわ</rt></ruby>す<ruby>言葉<rt>ことば</rt></ruby>はどれでしょう。`,
        choices: [
          `<ruby>普通<rt>ふつう</rt></ruby>`,
          `<ruby>特別<rt>とくべつ</rt></ruby>`,
          `<ruby>同様<rt>どうよう</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㊳ 郡部
        text: `<ruby>市<rt>し</rt></ruby>のように<ruby>人<rt>ひと</rt></ruby>が<ruby>多<rt>おお</rt></ruby>く<ruby>集<rt>あつ</rt></ruby>まっている<ruby>地域<rt>ちいき</rt></ruby>ではなく、<ruby>町<rt>まち</rt></ruby>や<ruby>村<rt>むら</rt></ruby>が<ruby>集<rt>あつ</rt></ruby>まっている<ruby>地域<rt>ちいき</rt></ruby>をまとめて<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>市街地<rt>しがいち</rt></ruby>`,
          `<ruby>郡部<rt>ぐんぶ</rt></ruby>`,
          `<ruby>工業地<rt>こうぎょうち</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㊴ 戦争
        text: `<ruby>国<rt>くに</rt></ruby>どうしや<ruby>大<rt>おお</rt></ruby>きな<ruby>集団<rt>しゅうだん</rt></ruby>どうしが、<ruby>武器<rt>ぶき</rt></ruby>を<ruby>使<rt>つか</rt></ruby>ってあらそうとても<ruby>大<rt>おお</rt></ruby>きなあらそいを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>競争<rt>きょうそう</rt></ruby>`,
          `<ruby>試合<rt>しあい</rt></ruby>`,
          `<ruby>戦争<rt>せんそう</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ㊵ 戦争（重複）
        text: `<ruby>昔<rt>むかし</rt></ruby>の<ruby>日本<rt>にほん</rt></ruby>や<ruby>世界<rt>せかい</rt></ruby>の<ruby>歴史<rt>れきし</rt></ruby>で、たくさんの<ruby>人<rt>ひと</rt></ruby>がたたかいにまきこまれ、<ruby>町<rt>まち</rt></ruby>やくらしが<ruby>大<rt>おお</rt></ruby>きく<ruby>変<rt>か</rt></ruby>わった<ruby>出来事<rt>できごと</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>革命<rt>かくめい</rt></ruby>`,
          `<ruby>災害<rt>さいがい</rt></ruby>`,
          `<ruby>戦争<rt>せんそう</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ㊶ 最初（重複）
        text: `ながい<ruby>行列<rt>ぎょうれつ</rt></ruby>の<ruby>中<rt>なか</rt></ruby>で、いちばん<ruby>前<rt>まえ</rt></ruby>に<ruby>立<rt>た</rt></ruby>つ<ruby>位置<rt>いち</rt></ruby>や、ものごとがはじまるいちばんはじめの<ruby>部分<rt>ぶぶん</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>最後<rt>さいご</rt></ruby>`,
          `<ruby>中央<rt>ちゅうおう</rt></ruby>`,
          `<ruby>最初<rt>さいしょ</rt></ruby>`
        ],
        correctIndex: 2
      },
      {
        // ㊷ 学校給食
        text: `<ruby>学校<rt>がっこう</rt></ruby>で、ひるにみんなでおなじ<ruby>献立<rt>こんだて</rt></ruby>を<ruby>食<rt>た</rt></ruby>べる<ruby>食事<rt>しょくじ</rt></ruby>のことを<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `お<ruby>弁当<rt>べんとう</rt></ruby>`,
          `<ruby>学校給食<rt>がっこうきゅうしょく</rt></ruby>`,
          `<ruby>外食<rt>がいしょく</rt></ruby>`
        ],
        correctIndex: 1
      },
      {
        // ㊸ 飛行機
        text: `<ruby>空港<rt>くうこう</rt></ruby>を<ruby>出発<rt>しゅっぱつ</rt></ruby>して、<ruby>空<rt>そら</rt></ruby>の<ruby>上<rt>うえ</rt></ruby>をながいきょり<ruby>移動<rt>いどう</rt></ruby>し、<ruby>人<rt>ひと</rt></ruby>や<ruby>荷物<rt>にもつ</rt></ruby>をはこぶ<ruby>大<rt>おお</rt></ruby>きなのりものはどれでしょう。`,
        choices: [
          `<ruby>新幹線<rt>しんかんせん</rt></ruby>`,
          `<ruby>飛行機<rt>ひこうき</rt></ruby>`,
          `フェリー`
        ],
        correctIndex: 1
      },
      {
        // ㊹ 包帯
        text: `けがをしたときに、<ruby>血<rt>ち</rt></ruby>をとめたり、<ruby>傷口<rt>きずぐち</rt></ruby>をまもったりするために<ruby>体<rt>からだ</rt></ruby>にまく<ruby>白<rt>しろ</rt></ruby>い<ruby>布<rt>ぬの</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>絆創膏<rt>ばんそうこう</rt></ruby>`,
          `<ruby>包帯<rt>ほうたい</rt></ruby>`,
          `テープ`
        ],
        correctIndex: 1
      },
      {
        // ㊺ 熱帯
        text: `<ruby>一年中<rt>いちねんじゅう</rt></ruby>あたたかく、<ruby>雨<rt>あめ</rt></ruby>が<ruby>多<rt>おお</rt></ruby>く、ジャングルが<ruby>広<rt>ひろ</rt></ruby>がるような<ruby>地域<rt>ちいき</rt></ruby>の<ruby>気候帯<rt>きこうたい</rt></ruby>を<ruby>何<rt>なん</rt></ruby>というでしょう。`,
        choices: [
          `<ruby>砂漠<rt>さばく</rt></ruby>`,
          `<ruby>森林<rt>しんりん</rt></ruby>`,
          `<ruby>熱帯<rt>ねったい</rt></ruby>`
        ],
        correctIndex: 2
      }
    ];

    // --- クイズ状態＆しかけ設定（ここから下は元のまま + 同期フック） ---
    let currentIndex = 0;
    let score = 0;
    let answeredCurrent = false;

    let quizOrder = [];
    let currentCorrectIndex = 0;

    // ★オンラインでのみ使う：P1が決める「出題順（questionsのindex配列）」と「選択肢並び（0,1,2）」
    //   既存のquestionsはそのまま。同期は index配列で行う。
    let onlineOrderIdx = [];               // [qIndex,...]
    let onlineChoiceOrderByTurn = {};      // { turnNumber: [0,1,2] }
    let onlineGimmickByTurn = {};          // { turnNumber: {type, cardNums?, treasure?, final?} }
    let onlineTurnOwner = 1;               // 1 or 2（ターン制：問題ごとに交代）
    let onlineStarted = false;

    const qTextEl = document.getElementById("questionText");
    const qHintEl = document.getElementById("questionHint");
    const choicesEl = document.getElementById("choicesContainer");
    const feedbackEl = document.getElementById("feedback");
    const qNumberEl = document.getElementById("qNumber");
    const qTotalEl = document.getElementById("qTotal");
    const progressFillEl = document.getElementById("progressFill");
    const scoreTextEl = document.getElementById("scoreText");
    const nextBtn = document.getElementById("nextBtn");
    const resultArea = document.getElementById("resultArea");
    const rouletteWheelEl = document.getElementById("rouletteWheel");
    const gimmickLabelEl = document.querySelector(".roulette-label");
    const cardContainerEl = document.getElementById("cardContainer");
    const turnNoteEl = document.getElementById("turnNote");

    const startBtn = document.getElementById("startBtn");
    const resetBtn = document.getElementById("resetBtn");
    const roomInput = document.getElementById("roomInput");
    const makeRoomUrlBtn = document.getElementById("makeRoomUrlBtn");
    const urlP1 = document.getElementById("urlP1");
    const urlP2 = document.getElementById("urlP2");
    const onlineDot = document.getElementById("onlineDot");
    const onlineLabel = document.getElementById("onlineLabel");

    const GIMMICK_TYPES = ["roulette", "dice", "treasure", "card"];

    let currentGimmickType = null;
    let gimmickInterval = null;
    let gimmickSpinning = false;
    let gimmickEnabled = false;

    let rouletteValue = 1;
    let diceValue = 1;
    let cardChosen = false;

    function shuffle(array) {
      const arr = array.slice();
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function isOnlineActive(){
      return ONLINE.enabled && ONLINE.ready && ONLINE.me;
    }
    function isP1(){
      return isOnlineActive() && ONLINE.me === 1;
    }
    function myTurn(){
      return !isOnlineActive() || (ONLINE.me === onlineTurnOwner);
    }
    function setOnlineBadge(on, label){
      if(!onlineDot || !onlineLabel) return;
      onlineDot.classList.remove("on","off");
      onlineDot.classList.add(on ? "on" : "off");
      onlineLabel.textContent = label;
    }
    function updateTurnNote(){
      if(!turnNoteEl) return;
      if(!isOnlineActive()){
        turnNoteEl.textContent = "";
        return;
      }
      const mine = (ONLINE.me === onlineTurnOwner);
      turnNoteEl.textContent = mine ? "あなたのターン" : "相手のターン";
    }

    // ---------- オンライン：DBヘルパ ----------
    function roomBase(){
      return `rooms/${ONLINE.room}`;
    }
    function stateRef(){
      return ref(ONLINE.db, `${roomBase()}/state`);
    }
    function actionsRef(){
      return ref(ONLINE.db, `${roomBase()}/actions`);
    }
    async function sendAction(type, payload = {}){
      if(!isOnlineActive()) return;
      if(ONLINE.suppress) return;

      const action = {
        type,
        payload,
        me: ONLINE.me,
        at: Date.now()
      };
      await push(actionsRef(), action);
    }

    function resetGimmick() {
      if (gimmickInterval) {
        clearInterval(gimmickInterval);
        gimmickInterval = null;
      }
      gimmickSpinning = false;
      gimmickEnabled = false;
      currentGimmickType = null;
      rouletteValue = 1;
      diceValue = 1;
      cardChosen = false;

      if (rouletteWheelEl) {
        rouletteWheelEl.textContent = "？";
        rouletteWheelEl.classList.add("disabled");
        rouletteWheelEl.style.display = "inline-flex";
      }
      if (cardContainerEl) {
        cardContainerEl.innerHTML = "";
        cardContainerEl.style.display = "none";
      }
      if (gimmickLabelEl) {
        gimmickLabelEl.textContent = "せいかいしたら しかけが でるよ";
      }
    }

    function setupCardGimmick(fixedNums = null) {
      if (!cardContainerEl) return;

      gimmickEnabled = true;
      cardChosen = false;

      if (rouletteWheelEl) {
        rouletteWheelEl.classList.add("disabled");
        rouletteWheelEl.style.display = "none";
      }
      cardContainerEl.style.display = "flex";
      cardContainerEl.innerHTML = "";

      const nums = fixedNums ? fixedNums.slice() : (() => {
        const tmp = [];
        while (tmp.length < 3) {
          const n = Math.floor(Math.random() * 10) + 1;
          if (!tmp.includes(n)) tmp.push(n);
        }
        return tmp;
      })();

      nums.forEach((num, idx) => {
        const card = document.createElement("div");
        card.className = "card-option";
        card.textContent = "？";
        card.dataset.value = String(num);
        card.dataset.idx = String(idx);

        card.addEventListener("click", async () => {
          if (!myTurn()) return;
          if (!gimmickEnabled || cardChosen) return;

          // ★オンライン：カード選択を同期
          if(isOnlineActive()){
            await sendAction("card_pick", { turn: currentIndex, pickIdx: idx });
          }

          applyCardPick(idx);
        });

        cardContainerEl.appendChild(card);
      });
    }

    function applyCardPick(pickIdx){
      if (!cardContainerEl) return;
      if (!gimmickEnabled || cardChosen) return;

      cardChosen = true;
      gimmickEnabled = false;

      const allCards = Array.from(cardContainerEl.getElementsByClassName("card-option"));
      allCards.forEach(c => c.classList.add("disabled"));

      const card = allCards[pickIdx];
      if(!card) return;

      card.classList.add("selected");
      card.style.transform = "scale(0.9)";
      const value = card.dataset.value;

      setTimeout(() => {
        card.textContent = value;
        card.style.transform = "scale(1)";
      }, 120);

      if (gimmickLabelEl) {
        gimmickLabelEl.textContent = `えらんだ すうじ：${value}`;
      }
    }

    function enableGimmickAfterCorrect(fixed = null) {
      if (!rouletteWheelEl || !gimmickLabelEl) return;

      // fixed: {type, cardNums}
      currentGimmickType = fixed?.type || GIMMICK_TYPES[Math.floor(Math.random() * GIMMICK_TYPES.length)];
      gimmickSpinning = false;

      switch (currentGimmickType) {
        case "roulette":
          gimmickEnabled = true;
          rouletteWheelEl.classList.remove("disabled");
          gimmickLabelEl.textContent = "ルーレットを まわそう！ 🎯";
          rouletteWheelEl.textContent = "▶";
          break;
        case "dice":
          gimmickEnabled = true;
          rouletteWheelEl.classList.remove("disabled");
          gimmickLabelEl.textContent = "サイコロを ふろう！ 🎲";
          rouletteWheelEl.textContent = "🎲";
          break;
        case "treasure":
          gimmickEnabled = true;
          rouletteWheelEl.classList.remove("disabled");
          gimmickLabelEl.textContent = "たからばこを あけてみよう！ 📦";
          rouletteWheelEl.textContent = "📦";
          break;
        case "card":
          gimmickLabelEl.textContent = "カードを 1まい えらぼう！ 🎴";
          setupCardGimmick(fixed?.cardNums || null);
          break;
      }
    }

    function startSpin() {
      if (!rouletteWheelEl || !currentGimmickType) return;

      if (gimmickInterval) {
        clearInterval(gimmickInterval);
        gimmickInterval = null;
      }
      gimmickSpinning = true;
      rouletteValue = 1;
      diceValue = 1;

      gimmickInterval = setInterval(() => {
        switch (currentGimmickType) {
          case "roulette":
            rouletteValue++;
            if (rouletteValue > 10) rouletteValue = 1;
            rouletteWheelEl.textContent = String(rouletteValue);
            break;
          case "dice":
            diceValue = Math.floor(Math.random() * 6) + 1;
            rouletteWheelEl.textContent = "🎲 " + diceValue;
            break;
        }
      }, 80);
    }

    function stopSpin() {
      if (gimmickInterval) {
        clearInterval(gimmickInterval);
        gimmickInterval = null;
      }
      gimmickSpinning = false;
      gimmickEnabled = false;
      if (rouletteWheelEl) {
        rouletteWheelEl.classList.add("disabled");
      }
    }

    function revealTreasureOnce(fixedNum = null) {
      if (!rouletteWheelEl) return;

      gimmickSpinning = true;
      gimmickEnabled = false;
      rouletteWheelEl.classList.add("disabled");

      const num = (typeof fixedNum === "number") ? fixedNum : (Math.floor(Math.random() * 10) + 1);
      rouletteWheelEl.textContent = "📦 → " + num;
    }

    if (rouletteWheelEl) {
      rouletteWheelEl.addEventListener("click", async () => {
        if (!myTurn()) return;
        if (!gimmickEnabled || !currentGimmickType) return;
        if (currentGimmickType === "card") return;

        if (currentGimmickType === "treasure") {
          if (!gimmickSpinning) {
            // ★オンライン：宝箱の数を同期（P1が決定）
            if(isOnlineActive()){
              if(ONLINE.me !== onlineTurnOwner) return; // 念のため
              // 決定は押した側（ターン側）が行う
              const num = Math.floor(Math.random() * 10) + 1;
              await sendAction("treasure_reveal", { turn: currentIndex, num });
              revealTreasureOnce(num);
            }else{
              revealTreasureOnce();
            }
          }
        } else {
          if (!gimmickSpinning) {
            startSpin();
            if(isOnlineActive()){
              await sendAction("spin_start", { turn: currentIndex, kind: currentGimmickType });
            }
          } else {
            // ★オンライン：停止時の最終値を同期
            if(isOnlineActive()){
              const final = (currentGimmickType === "roulette") ? rouletteValue : diceValue;
              await sendAction("spin_stop", { turn: currentIndex, kind: currentGimmickType, final });
              stopSpin();
              // 表示を最終値に固定（すでに表示されているのでOK）
            }else{
              stopSpin();
            }
          }
        }
      });
    }

    function updateProgress() {
      const total = quizOrder.length || questions.length;
      const percent = (currentIndex / total) * 100;
      progressFillEl.style.width = percent + "%";
    }

    function getQuestionByOrderIndex(orderPos){
      const qi = isOnlineActive() ? onlineOrderIdx[orderPos] : quizOrder[orderPos].__idx;
      return { q: questions[qi], qi };
    }

    function renderQuestion() {
      const { q, qi } = getQuestionByOrderIndex(currentIndex);
      qNumberEl.textContent = (currentIndex + 1).toString();
      updateProgress();

      qTextEl.innerHTML = q.text;
      qHintEl.textContent = q.hint || "";
      feedbackEl.innerHTML = "";
      feedbackEl.className = "feedback";
      resultArea.innerHTML = "";

      resetGimmick();

      choicesEl.innerHTML = "";

      // ★選択肢順の決定：オフラインは従来通りランダム
      // ★オンラインは P1 が turnごとに決めて state に保存 → P2はそれを使用
      const turnKey = String(currentIndex);
      let choiceOrder = null;

      if(isOnlineActive()){
        choiceOrder = onlineChoiceOrderByTurn[turnKey];
        if(!choiceOrder){
          // まだ届いていない場合は何もしない（state受信待ち）
          choicesEl.innerHTML = "";
          const p = document.createElement("div");
          p.className = "hint";
          p.textContent = "同期中…";
          choicesEl.appendChild(p);
          nextBtn.classList.add("disabled");
          answeredCurrent = false;
          updateTurnNote();
          return;
        }
      }else{
        choiceOrder = shuffle([0,1,2]);
      }

      currentCorrectIndex = 0;

      choiceOrder.forEach((choiceIdx, buttonIdx) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "choice-btn";

        const labelSpan = document.createElement("span");
        labelSpan.className = "label";
        labelSpan.innerHTML = q.choices[choiceIdx];

        const markSpan = document.createElement("span");
        markSpan.className = "mark";
        markSpan.textContent = String.fromCharCode(65 + buttonIdx);

        btn.appendChild(labelSpan);
        btn.appendChild(markSpan);

        if (choiceIdx === q.correctIndex) {
          currentCorrectIndex = buttonIdx;
        }

        btn.addEventListener("click", async () => {
          if(!myTurn()) return;
          // ★オンライン：選択を同期（ターンの人のみ）
          if(isOnlineActive()){
            await sendAction("choose", { turn: currentIndex, buttonIndex });
          }
          handleChoice(buttonIdx);
        });

        // ★オンライン：相手ターンは押せない（見た目はそのまま、クリック時にreturn）
        choicesEl.appendChild(btn);
      });

      // ★オンライン：ギミック種類もP1が決める（正解時に state に入ってくる）→ enable時に fixed を渡す
      nextBtn.textContent =
        currentIndex === (isOnlineActive() ? onlineOrderIdx.length : quizOrder.length) - 1
          ? "さいごの けっか を みる"
          : "えらんだら つぎへ ➜";
      nextBtn.classList.add("disabled");
      answeredCurrent = false;

      updateTurnNote();
    }

    function handleChoice(buttonIndex) {
      if (answeredCurrent) return;
      const buttons = Array.from(choicesEl.getElementsByClassName("choice-btn"));
      answeredCurrent = true;

      buttons.forEach(btn => btn.classList.add("disabled"));

      if (buttonIndex === currentCorrectIndex) {
        score++;
        scoreTextEl.textContent = `せいかい：${score} もん`;
        feedbackEl.textContent = "⭕ 正解！";
        feedbackEl.className = "feedback correct";
        buttons[buttonIndex].classList.add("correct");

        // ★オンライン：ギミック種類は state から（P1が決定）
        if(isOnlineActive()){
          const fixed = onlineGimmickByTurn[String(currentIndex)] || null;
          enableGimmickAfterCorrect(fixed);
        }else{
          enableGimmickAfterCorrect();
        }
      } else {
        feedbackEl.textContent = "❌ ざんねん。";
        feedbackEl.className = "feedback wrong";
        buttons[buttonIndex].classList.add("wrong");
        const correctBtn = buttons[currentCorrectIndex];
        if (correctBtn) correctBtn.classList.add("correct");
        resetGimmick();
      }

      nextBtn.classList.remove("disabled");
    }

    nextBtn.addEventListener("click", async () => {
      if (nextBtn.classList.contains("disabled")) return;
      if(!myTurn()) return;

      if(isOnlineActive()){
        await sendAction("next", { turn: currentIndex });
      }

      if (currentIndex < (isOnlineActive() ? onlineOrderIdx.length : quizOrder.length) - 1) {
        currentIndex++;
        // ★ターン交代（問題ごと）
        if(isOnlineActive()){
          onlineTurnOwner = (onlineTurnOwner === 1) ? 2 : 1;
          updateTurnNote();
        }
        renderQuestion();
      } else {
        showResult();
      }
    });

    function showResult() {
      const total = isOnlineActive() ? onlineOrderIdx.length : quizOrder.length;
      const percent = Math.round((score / total) * 100);
      let message = "";

      if (percent === 100) {
        message = "💮 すばらしい！ ぜんぶ 正解です。ごいりょく ばっちり！";
      } else if (percent >= 70) {
        message = "✨ よくできました！ あとすこしで まんてんです。";
      } else if (percent >= 50) {
        message = "◯ がんばりました。 もういちど チャレンジしてみよう。";
      } else {
        message = "📘 これから どんどん ごいを ふやしていこう。";
      }

      resultArea.innerHTML =
        `けっか：${score} / ${total} もん <br>${message}`;

      const restart = document.createElement("button");
      restart.type = "button";
      restart.textContent = "もういちど チャレンジ";
      restart.className = "restart-btn";
      restart.addEventListener("click", async () => {
        // オフラインは従来通り
        if(!isOnlineActive()){
          restartQuiz();
          return;
        }
        // オンラインは P1 のみが reset できる（仕様）
        if(!isP1()) return;
        await sendAction("reset", {});
        await hostReset();
      });
      resultArea.appendChild(restart);
    }

    function restartQuiz() {
      score = 0;
      scoreTextEl.textContent = "せいかい：0 もん";

      // オフライン：従来通り questions を shuffle した配列
      const shuffled = shuffle(questions.map((q, idx) => ({...q, __idx: idx})));
      quizOrder = shuffled;

      currentIndex = 0;
      qTotalEl.textContent = quizOrder.length.toString();
      updateProgress();
      renderQuestion();
      resetGimmick();
    }

    // ========== ★オンライン：ホスト（P1）state生成/更新 ==========
    function makeInitialOnlineState(){
      const orderIdx = shuffle(Array.from({length: questions.length}, (_,i)=>i));
      const choiceOrders = {};
      const gimmicks = {};
      for(let t=0; t<orderIdx.length; t++){
        choiceOrders[String(t)] = shuffle([0,1,2]);
        // ギミック種類は「正解時」に使うが、両者一致のため事前決定
        const type = GIMMICK_TYPES[Math.floor(Math.random() * GIMMICK_TYPES.length)];
        if(type === "card"){
          const nums = [];
          while(nums.length < 3){
            const n = Math.floor(Math.random() * 10) + 1;
            if(!nums.includes(n)) nums.push(n);
          }
          gimmicks[String(t)] = { type, cardNums: nums };
        }else{
          gimmicks[String(t)] = { type };
        }
      }
      return {
        started: false,
        orderIdx,
        choiceOrders,
        gimmicks,
        currentIndex: 0,
        turnOwner: 1,
        score: 0,
        updatedAt: serverTimestamp()
      };
    }

    async function hostEnsureState(){
      // state が無ければ作る
      const snap = await get(stateRef());
      if(!snap.exists()){
        const st = makeInitialOnlineState();
        await set(stateRef(), st);
      }
    }

    async function hostStart(){
      await hostEnsureState();
      await update(stateRef(), {
        started: true,
        currentIndex: 0,
        turnOwner: 1,
        score: 0,
        updatedAt: serverTimestamp()
      });
    }

    async function hostReset(){
      // 仕様：リセットは P1 のみ
      const st = makeInitialOnlineState();
      st.started = true; // リセット＝即スタート扱い
      await set(stateRef(), st);
    }

    // ========== ★オンライン：受信適用 ==========
    function applyState(st){
      onlineStarted = !!st.started;
      onlineOrderIdx = Array.isArray(st.orderIdx) ? st.orderIdx.slice() : [];
      onlineChoiceOrderByTurn = (st.choiceOrders && typeof st.choiceOrders === "object") ? st.choiceOrders : {};
      onlineGimmickByTurn = (st.gimmicks && typeof st.gimmicks === "object") ? st.gimmicks : {};
      currentIndex = Number(st.currentIndex || 0);
      onlineTurnOwner = Number(st.turnOwner || 1);
      score = Number(st.score || 0);

      scoreTextEl.textContent = `せいかい：${score} もん`;
      qTotalEl.textContent = String(onlineOrderIdx.length || questions.length);
      updateProgress();
      updateTurnNote();

      // started=false の間は「同期待ち」表示にする（P1のスタートを待つ）
      if(!onlineStarted){
        qTextEl.textContent = "スタートを待っています…";
        qHintEl.textContent = "";
        choicesEl.innerHTML = "";
        feedbackEl.textContent = "";
        resultArea.innerHTML = "";
        resetGimmick();
        nextBtn.classList.add("disabled");
        nextBtn.textContent = "こたえを えらんでね";
        return;
      }

      renderQuestion();
    }

    function applyAction(action){
      const type = action?.type;
      const p = action?.payload || {};

      // 自分が送ったactionでも、state更新と併用で二重適用しないよう、必要最小限のみ適用
      switch(type){
        case "choose": {
          if(Number(p.turn) !== currentIndex) return;
          // 既に回答済みなら無視
          if(answeredCurrent) return;
          ONLINE.suppress = true;
          try{
            handleChoice(Number(p.buttonIndex));
          }finally{
            ONLINE.suppress = false;
          }
          break;
        }
        case "next": {
          if(Number(p.turn) !== currentIndex) return;
          if(nextBtn.classList.contains("disabled")) return;
          ONLINE.suppress = true;
          try{
            // 既存の click と同じ流れ
            if (currentIndex < onlineOrderIdx.length - 1) {
              currentIndex++;
              onlineTurnOwner = (onlineTurnOwner === 1) ? 2 : 1;
              renderQuestion();
            } else {
              showResult();
            }
          }finally{
            ONLINE.suppress = false;
          }
          break;
        }
        case "spin_start": {
          if(Number(p.turn) !== currentIndex) return;
          if(!currentGimmickType) return;
          if(currentGimmickType !== p.kind) return;
          if(!gimmickSpinning){
            ONLINE.suppress = true;
            try{ startSpin(); } finally { ONLINE.suppress = false; }
          }
          break;
        }
        case "spin_stop": {
          if(Number(p.turn) !== currentIndex) return;
          if(!currentGimmickType) return;
          if(currentGimmickType !== p.kind) return;
          ONLINE.suppress = true;
          try{
            // 表示を最終値にして停止
            if(currentGimmickType === "roulette"){
              rouletteValue = Number(p.final || 1);
              if(rouletteWheelEl) rouletteWheelEl.textContent = String(rouletteValue);
            }else if(currentGimmickType === "dice"){
              diceValue = Number(p.final || 1);
              if(rouletteWheelEl) rouletteWheelEl.textContent = "🎲 " + diceValue;
            }
            stopSpin();
          }finally{ ONLINE.suppress = false; }
          break;
        }
        case "treasure_reveal": {
          if(Number(p.turn) !== currentIndex) return;
          ONLINE.suppress = true;
          try{
            revealTreasureOnce(Number(p.num));
          }finally{ ONLINE.suppress = false; }
          break;
        }
        case "card_pick": {
          if(Number(p.turn) !== currentIndex) return;
          ONLINE.suppress = true;
          try{
            applyCardPick(Number(p.pickIdx));
          }finally{ ONLINE.suppress = false; }
          break;
        }
        case "start": {
          // state が更新されるのでここでは何もしない
          break;
        }
        case "reset": {
          // state が更新されるのでここでは何もしない
          break;
        }
      }
    }

    // ========== ★オンライン：初期化（失敗時はオフライン継続） ==========
    async function tryInitOnline(){
      if(!ONLINE.room || !ONLINE.me) return;

      try{
        const {
          initializeApp, getDatabase, ref, set, update, onValue, onChildAdded, push, serverTimestamp, get, child
        } = await loadFirebase();

        ONLINE.app = initializeApp(firebaseConfig);

        // RTDB の databaseURL が config に無い場合があるので、複数候補で try
        const regions = [
          "asia-northeast1","asia-northeast2","asia-northeast3",
          "asia-east1","asia-east2","asia-southeast1","asia-southeast2",
          "us-central1","us-east1","us-east4","northamerica-northeast1",
          "europe-west1","europe-west2","europe-west3","europe-west4","europe-north1",
          "australia-southeast1","southamerica-east1"
        ];

        // databaseURL が config に無い場合があるので、複数候補で try
        const candidates = [
          null,
          `https://${firebaseConfig.projectId}-default-rtdb.firebaseio.com`,
          `https://${firebaseConfig.projectId}-default-rtdb.firebasedatabase.app`,
          ...regions.map(r => `https://${firebaseConfig.projectId}-default-rtdb.${r}.firebasedatabase.app`)
        ];

        let db = null;
        let lastErr = null;
        for(const url of candidates){
          try{
            db = url ? getDatabase(ONLINE.app, url) : getDatabase(ONLINE.app);
            // 軽いreadで確認
            await get(child(ref(db), `${roomBase()}/__ping`));
            lastErr = null;
            break;
          }catch(e){
            lastErr = e;
            db = null;
          }
        }
        if(!db){
          throw lastErr || new Error("RTDB init failed");
        }

        ONLINE.db = db;
        ONLINE.enabled = true;
        ONLINE.ready = true;

        setOnlineBadge(true, `オンライン（me=${ONLINE.me} / room=${ONLINE.room}）`);

        // P1はstateを確保
        if(isP1()){
          await hostEnsureState();
        }

        // state購読
        onValue(stateRef(), (snap) => {
          const st = snap.val();
          if(!st) return;
          applyState(st);
        });

        // actions購読
        onChildAdded(actionsRef(), (snap) => {
          const key = snap.key || "";
          if(!key) return;
          if(key <= (ONLINE.lastActionKey || "")) return;
          ONLINE.lastActionKey = key;

          const action = snap.val();
          applyAction(action);
        });

      }catch(err){
        console.warn("ONLINE init failed:", err);
        ONLINE.enabled = false;
        ONLINE.ready = false;
        setOnlineBadge(false, "オフライン（接続失敗）");
        document.getElementById("onlineHint").innerHTML = "接続に失敗しました。<br>Firebaseコンソールで <b>Realtime Database</b> を有効化し、URL（〜default-rtdb…）が存在するか確認してください。<br>（失敗時は自動的にオフライン動作に戻ります）";
      }
    }

    // ========== 右パネル：URL作成 ==========
    function makeRoomUrls(room){
      const base = location.origin + location.pathname;
      const u1 = `${base}?room=${encodeURIComponent(room)}&me=1`;
      const u2 = `${base}?room=${encodeURIComponent(room)}&me=2`;
      return { u1, u2 };
    }
    function fillUrlBoxes(room){
      if(!urlP1 || !urlP2) return;
      const { u1, u2 } = makeRoomUrls(room);
      urlP1.value = u1;
      urlP2.value = u2;
    }
    if(roomInput){
      roomInput.value = ONLINE.room || "";
      roomInput.addEventListener("input", () => fillUrlBoxes(roomInput.value.trim()));
      fillUrlBoxes(roomInput.value.trim());
    }
    if(makeRoomUrlBtn){
      makeRoomUrlBtn.addEventListener("click", async () => {
        const room = (roomInput?.value || "").trim();
        if(!room) return;
        fillUrlBoxes(room);
        // コピーしやすいよう選択
        urlP1?.focus(); urlP1?.select();
      });
    }
    if(urlP1){ urlP1.addEventListener("click", () => { urlP1.select(); }); }
    if(urlP2){ urlP2.addEventListener("click", () => { urlP2.select(); }); }

    // ========== スタート/リセット（P1のみ） ==========
    function setButtonEnabled(btn, enabled){
      if(!btn) return;
      btn.classList.toggle("disabled", !enabled);
      btn.disabled = !enabled;
    }
    function updateControlButtons(){
      const online = isOnlineActive();
      if(!online){
        setButtonEnabled(startBtn, false);
        setButtonEnabled(resetBtn, false);
        return;
      }
      // 仕様：P1のみ start/reset
      setButtonEnabled(startBtn, ONLINE.me === 1);
      setButtonEnabled(resetBtn, ONLINE.me === 1);
    }
    if(startBtn){
      startBtn.addEventListener("click", async () => {
        if(!isOnlineActive()) return;
        if(!isP1()) return;
        try{
          await sendAction("start", {});
          await hostStart();
        }catch(err){
          console.warn("start failed:", err);
          setOnlineBadge(false, "オフライン（開始失敗）");
          ONLINE.enabled = false; ONLINE.ready = false;
          updateControlButtons();
          // ★接続に失敗してもオフラインとして開始できるようにする
          restartQuiz();
          alert("オンライン開始に失敗しました。
Realtime Database が有効か / ルールが許可か / Database URL が正しいか確認してください。
（オフライン動作に戻しました）");
        }
      });
    }
    if(resetBtn){
      resetBtn.addEventListener("click", async () => {
        if(!isOnlineActive()) return;
        if(!isP1()) return;
        try{
          await sendAction("reset", {});
          await hostReset();
        }catch(err){
          console.warn("reset failed:", err);
          setOnlineBadge(false, "オフライン（リセット失敗）");
          ONLINE.enabled = false; ONLINE.ready = false;
          updateControlButtons();
          restartQuiz();
          alert("オンラインリセットに失敗しました。
Realtime Database が有効か / ルールが許可か / Database URL が正しいか確認してください。
（オフライン動作に戻しました）");
        }
      });
    }

    // ========== 起動フロー ==========
    if(ROOM && (ME === 1 || ME === 2)){
      setOnlineBadge(false, "オンライン準備中…");
    }else{
      setOnlineBadge(false, "オフライン");
    }

    await tryInitOnline();
    updateControlButtons();

    // オフラインは従来通り即スタート
    if(!isOnlineActive()){
      restartQuiz();
    }else{
      // オンライン：stateが来るまで待つ（P1がスタートを押す）
      // state購読後に applyState が動く
    }
  </script>
</body>
</html>
