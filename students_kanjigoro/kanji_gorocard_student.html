<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ã‹ã‚“å­—ã‚´ãƒ­ã‚«ãƒ¼ãƒ‰</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --ink:#111827;
      --muted:#6b7280;
      --border:#e5e7eb;
      --accent:#3B2C5A;
      --good:#16a34a;
      --warn:#2563eb;
      --shadow: 0 12px 30px rgba(17,24,39,.10);
      --radius:18px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: "Noto Sans JP", system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Yu Gothic", sans-serif;
      color:var(--ink);
      background:linear-gradient(180deg,#fafbff 0%, var(--bg) 60%, #fff 120%);
    }
    header{
      position:sticky; top:0;
      background:rgba(250,251,255,.9);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--border);
      z-index:10;
    }
    .wrap{ max-width:980px; margin:0 auto; padding:14px 16px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .spacer{ flex:1; min-width:12px; }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:800; letter-spacing:.02em;
    }
    .pill{
      font-size:12px;
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background:#fff;
      color:var(--muted);
    }
    main .wrap{ padding:22px 16px 40px; }
    .panel{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      padding:14px;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }
    @media (min-width: 860px){
      .grid{ grid-template-columns: 2fr 1fr; }
    }

    /* Card */
    .flash{ padding:16px; }
    .flashTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .progress{
      font-weight:700;
      color:var(--accent);
      letter-spacing:.03em;
    }
    .small{
      font-size:12px;
      color:var(--muted);
    }
    .cardBox{
      border:1px solid var(--border);
      border-radius:22px;
      background:linear-gradient(180deg,#ffffff 0%, #fbfbff 100%);
      box-shadow: 0 18px 50px rgba(17,24,39,.08);
      min-height: 280px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:22px;
      position:relative;
      overflow:hidden;
    }
    .stageLabel{
      position:absolute;
      top:14px; left:14px;
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(59,44,90,.08);
      color:var(--accent);
      border:1px solid rgba(59,44,90,.18);
    }
    .cardText{
      text-align:center;
      line-height:1.3;
      word-break: break-word;
    }
    .frontText{ font-size: clamp(28px, 4vw, 52px); font-weight:900; }
    .mnemonicText{ font-size: clamp(22px, 3.2vw, 40px); font-weight:800; }
    .answerText{ font-size: clamp(90px, 10vw, 150px); font-weight:900; letter-spacing:.05em; }

    .hintBox{
      margin-top:12px;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
    }
    .hintText{
      font-weight:800;
      color:var(--accent);
      background:rgba(59,44,90,.08);
      border:1px solid rgba(59,44,90,.18);
      padding:10px 12px;
      border-radius:14px;
      min-width: 160px;
      text-align:center;
    }

    /* Controls */
    .controls{
      margin-top:14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
      align-items:center;
    }
    button, select, input, textarea{ font: inherit; }
    button{
      border:1px solid var(--border);
      background:#fff;
      color:var(--ink);
      border-radius:14px;
      padding:10px 12px;
      font-weight:800;
      cursor:pointer;
      box-shadow: 0 6px 16px rgba(17,24,39,.06);
    }
    button:hover{ transform: translateY(-1px); }
    button:active{ transform: translateY(0); }
    .btnAccent{
      border-color: rgba(59,44,90,.35);
      background: var(--accent);
      color:#fff;
    }
    .btnGhost{ background:transparent; box-shadow:none; }
    .btnGood{
      border-color: rgba(22,163,74,.35);
      background: rgba(22,163,74,.10);
      color: var(--good);
    }
    .btnWarn{
      border-color: rgba(37,99,235,.35);
      background: rgba(37,99,235,.10);
      color: var(--warn);
    }
    .btnGood.active{ background: var(--good); color:#fff; }
    .btnWarn.active{ background: var(--warn); color:#fff; }
    .kbd{
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--border);
      background:#fff;
      border-bottom-width:2px;
      padding:2px 6px;
      border-radius:8px;
      font-weight:700;
    }

    /* Sidebar */
    .side h3{
      margin:0 0 10px;
      font-size:14px;
      color:#111827;
      letter-spacing:.02em;
    }
    select{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      background:#fff;
      font-weight:700;
      min-width: 180px;
    }
    .side .mini{
      font-size:12px;
      color:var(--muted);
      line-height:1.5;
    }
    .list{
      margin-top:12px;
      border-top:1px dashed var(--border);
      padding-top:12px;
      max-height: 280px;
      overflow:auto;
    }
    .item{
      display:flex;
      gap:10px;
      align-items:flex-start;
      padding:10px;
      border:1px solid var(--border);
      border-radius:14px;
      background:#fff;
      margin-bottom:10px;
      cursor:pointer;
    }
    .badge{
      font-size:11px;
      font-weight:900;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      white-space:nowrap;
    }
    .badge.good{ border-color: rgba(22,163,74,.35); color: var(--good); background: rgba(22,163,74,.08); }
    .badge.warn{ border-color: rgba(37,99,235,.35); color: var(--warn); background: rgba(37,99,235,.08); }
    .itemTitle{ font-weight:900; }
    .itemSub{ font-size:12px; color:var(--muted); margin-top:2px; display:none; }

    /* Modal */
    dialog{
      border:none;
      border-radius: 18px;
      padding:0;
      width:min(820px, calc(100vw - 24px));
      box-shadow: 0 30px 90px rgba(17,24,39,.25);
    }
    .modalHead{
      padding:14px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background:#fff;
    }
    .modalHead b{ font-size:14px; }
    .modalBody{
      padding:14px 16px;
      background:#fff;
    }
    .modalBody label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin:10px 0 6px;
      font-weight:800;
    }
    input[type="text"], textarea{
      width:100%;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      outline:none;
    }
    textarea{ min-height: 90px; resize: vertical; }
    .modalFoot{
      padding:14px 16px;
      border-top:1px solid var(--border);
      background:#fff;
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
    .danger{
      border-color: rgba(220,38,38,.35);
      background: rgba(220,38,38,.10);
      color:#b91c1c;
    }
    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      background:#111827;
      color:#fff;
      padding:10px 12px;
      border-radius:999px;
      font-weight:800
      font-size:13px;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index:99;
    }
    .toast.show{ opacity: 1; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="row">
        <div class="brand">
          <span style="display:inline-flex;width:34px;height:34px;border-radius:12px;background:rgba(59,44,90,.10);border:1px solid rgba(59,44,90,.18);align-items:center;justify-content:center;font-weight:900;color:var(--accent);">å­—</span>
          <span>ã‹ã‚“å­—ã‚´ãƒ­ã‚«ãƒ¼ãƒ‰</span>
        </div>
        <div class="spacer"></div>
        
      </div>
    </div>
  </header>

  <main>
    <div class="wrap">
      <div class="grid">
        <!-- Flash panel -->
        <section class="panel flash" aria-label="ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚«ãƒ¼ãƒ‰">
          <div class="flashTop">
            <div>
              <div class="progress" id="progressText">0 / 0</div>
              <div class="small" id="filterNote">ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼šã™ã¹ã¦</div>
            </div>
            <button id="shuffleBtn" class="btnGhost" style="font-weight:900;">ğŸ”€ ã‚·ãƒ£ãƒƒãƒ•ãƒ«</button>
          </div>

          <div class="cardBox" id="cardBox">
            <div class="stageLabel" id="stageLabel">è¡¨</div>
            <div class="cardText" id="cardText">
              <div class="frontText">ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¦ãã ã•ã„</div>
            </div>
          </div>

          <div class="hintBox">
            <button id="hintBtn" class="btnWarn">ãƒ’ãƒ³ãƒˆ</button>
            <div class="hintText" id="hintText">ï¼ˆãƒ’ãƒ³ãƒˆã¯ã“ã“ã«å‡ºã¾ã™ï¼‰</div>
          </div>

          <div class="controls">
            <button id="flipBtn" class="btnAccent">ã‚ãã‚‹</button>
            <button id="markNotBtn" class="btnWarn">ã¾ã </button>
            <button id="markLearnedBtn" class="btnGood">ãŠã¼ãˆãŸ</button>
            <button id="resetStageBtn">ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’ã•ã„ã—ã‚‡ã‹ã‚‰</button>
            <div class="row" style="gap:14px; justify-content:center; width:100%; margin-top:6px;">
              <button id="prevBtn" class="btnAccent" style="background:#6b4eff;">â† ã¾ãˆ</button>
              <button id="nextBtn" class="btnWarn" style="background:#fb923c;color:#111;">ã¤ã â†’</button>
            </div>

          </div>

           </section>

        <!-- Sidebar -->
        <aside class="panel side" aria-label="è¨­å®šã¨ã‚«ãƒ¼ãƒ‰ä¸€è¦§">
          <h3>ãƒ•ã‚£ãƒ«ã‚¿</h3>
          <div class="row">
            <select id="filterSelect">
              <option value="all">ã™ã¹ã¦</option>
              <option value="not">ã¾ã ï¼ˆnotï¼‰</option>
              <option value="learned">ãŠã¼ãˆãŸï¼ˆlearnedï¼‰</option>
            </select>
          </div>

          <h3 style="margin-top:16px;">ã‚«ãƒ¼ãƒ‰ç®¡ç†</h3>
          <div class="row">
            <button id="addBtn" class="btnAccent">ï¼‹ è¿½åŠ /ç·¨é›†</button>
          </div>

          <div class="row" style="margin-top:10px; gap:8px;">
            <select id="ioType" title="å½¢å¼ã‚’é¸ã¶">
              <option value="json">JSON</option>
              <option value="csv">CSV</option>
            </select>
            <button id="exportBtn">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
            <button id="importBtn">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
          </div>

        
          <div class="list" id="cardList"></div>

          <div class="row" style="margin-top:10px;">
            <button id="resetAllBtn" class="danger">çŠ¶æ…‹ã‚’å…¨ãƒªã‚»ãƒƒãƒˆï¼ˆå…¨éƒ¨notï¼‰</button>
            <button id="wipeBtn" class="danger">å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤</button>
          </div>
        </aside>
      </div>
    </div>
  </main>

  <!-- Modal -->
  <dialog id="editor">
    <div class="modalHead">
      <b>ã‚«ãƒ¼ãƒ‰ã®è¿½åŠ  / ç·¨é›†</b>
      <button class="btnGhost" id="closeEditorBtn">é–‰ã˜ã‚‹</button>
    </div>
    <div class="modalBody">
      <div class="small">ã€Œè¡¨é¢ã®ãƒ’ãƒ³ãƒˆã€â†’ã€Œã‚´ãƒ­ã€â†’ã€Œæ­£ã—ã„æ¼¢å­—ã€ã®é †ã«å‡ºã¾ã™ã€‚</div>

      <label for="fPrompt">è¡¨é¢ï¼ˆpromptï¼‰</label>
      <input id="fPrompt" type="text" placeholder="ä¾‹ï¼šãƒã‚¦æ¥­ã®ãƒã‚¦" />

      <label for="fMnemonic">ã‚´ãƒ­ï¼ˆmnemonicï¼‰</label>
      <textarea id="fMnemonic" placeholder="ä¾‹ï¼šã¾ãŒã£ãŸæ»‘ã‚Šå°ã«ãƒ¬ãƒ³ã‚³ãƒ³ãŒã¨ãŠã‚‹"></textarea>

      <label for="fAnswer">æ­£ã—ã„æ¼¢å­—ï¼ˆanswerï¼‰</label>
      <input id="fAnswer" type="text" placeholder="ä¾‹ï¼šè¾²" />

      <div class="row" style="margin-top:10px;">
        <button id="saveCardBtn" class="btnAccent">ä¿å­˜</button>
        <button id="newCardBtn">æ–°è¦ã«ã™ã‚‹</button>
        <div class="spacer"></div>
        <button id="deleteCardBtn" class="danger">ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤</button>
      </div>

      <div class="small" style="margin-top:10px;">
        â€»å‰Šé™¤ã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ï¼ˆå¿…è¦ãªã‚‰å…ˆã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ï¼‰
      </div>
    </div>
    <div class="modalFoot">
      <button id="seedBtn">ä¾‹ã®ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ ï¼ˆè¾²ï¼‰</button>
      <button id="closeEditorBtn2">é–‰ã˜ã‚‹</button>
    </div>
  </dialog>

  <div class="toast" id="toast">ä¿å­˜ã—ã¾ã—ãŸ</div>

<script>
(() => {
  const LS_KEY = "kanji_mnemonic_cards_v1"; // STUDENT MODE: always overwrite from CSV on startup

  // status: "not" | "learned"
  // CSV columns: prompt,mnemonic,answer,status (not/learned)

  // ---- Student-mode fixed spec ----
  // This app ALWAYS runs as if URL is: ?mode=student&csv=student-001.csv
  // On startup, it MUST fetch the CSV specified by csv=... (default student-001.csv),
  // and MUST overwrite localStorage every time.
  // Student progress is NOT authoritative; teacher CSV is the source of truth.
  function getStudentConfig(){
    const sp = new URLSearchParams(location.search);
    const mode = (sp.get("mode") || "student").toLowerCase();
    const csv = sp.get("csv") || "student-001.csv";
    return { mode, csv };
  }

  const $ = (id) => document.getElementById(id);

  const els = {
    progressText: $("progressText"),
    filterNote: $("filterNote"),
    stageLabel: $("stageLabel"),
    cardText: $("cardText"),
    hintBtn: $("hintBtn"),
    hintText: $("hintText"),
    flipBtn: $("flipBtn"),
    prevBtn: $("prevBtn"),
    nextBtn: $("nextBtn"),
    resetStageBtn: $("resetStageBtn"),
    markNotBtn: $("markNotBtn"),
    markLearnedBtn: $("markLearnedBtn"),

    filterSelect: $("filterSelect"),
    cardList: $("cardList"),

    addBtn: $("addBtn"),
    ioType: $("ioType"),
    exportBtn: $("exportBtn"),
    importBtn: $("importBtn"),

    resetAllBtn: $("resetAllBtn"),
    wipeBtn: $("wipeBtn"),

    editor: $("editor"),
    closeEditorBtn: $("closeEditorBtn"),
    closeEditorBtn2: $("closeEditorBtn2"),
    fPrompt: $("fPrompt"),
    fMnemonic: $("fMnemonic"),
    fAnswer: $("fAnswer"),
    saveCardBtn: $("saveCardBtn"),
    newCardBtn: $("newCardBtn"),
    deleteCardBtn: $("deleteCardBtn"),
    seedBtn: $("seedBtn"),
    toast: $("toast"),
    shuffleBtn: $("shuffleBtn"),
  };
  let cards = []; // STUDENT MODE: will be overwritten from CSV every startup
  let deck = [];          // current filtered ids (computed)
  let idx = 0;
  let stage = 0;          // 0 front, 1 mnemonic, 2 answer
  let pendingRebuild = false; // when status change makes card outside current filter

  function uid(){
    return Math.random().toString(36).slice(2, 10) + "_" + Date.now().toString(36);
  }

  function stableIdFromRow(i){
    // Stable id per row index so teacher CSV rows map consistently.
    return "row_" + String(i).padStart(4, "0");
  }

  function toast(msg){
    els.toast.textContent = msg;
    els.toast.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(() => els.toast.classList.remove("show"), 1200);
  }

  function normalizeStatus(s){
    const v = String(s || "").trim().toLowerCase();
    if(v === "learned") return "learned";
    if(v === "not") return "not";
    // backward compat
    if(v === "still") return "not";
    return "not";
  }

  function loadCards(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return [];
      const arr = JSON.parse(raw);
      if(!Array.isArray(arr)) return [];
      const migrated = arr.map(c => ({
        id: String(c.id ?? uid()),
        prompt: String(c.prompt ?? ""),
        mnemonic: String(c.mnemonic ?? ""),
        answer: String(c.answer ?? ""),
        status: normalizeStatus(c.status),
        updatedAt: Number(c.updatedAt ?? Date.now())
      })).filter(c => (c.prompt || c.mnemonic || c.answer));
      localStorage.setItem(LS_KEY, JSON.stringify(migrated));
      return migrated;
    }catch(e){
      console.warn(e);
      return [];
    }
  }

  function saveCards(){
    localStorage.setItem(LS_KEY, JSON.stringify(cards));
  }

  function getCardById(id){
    return cards.find(c => c.id === id) || null;
  }

  function currentFilter(){
    return els.filterSelect.value;
  }

  function makeDeck(filter){
    return cards
      .filter(c => (filter === "all") ? true : c.status === filter)
      .sort((a,b) => (b.updatedAt - a.updatedAt))
      .map(c => c.id);
  }

  function rebuildDeck(keepCurrentId){
    const filter = currentFilter();
    const prevId = keepCurrentId ? deck[idx] : null;

    deck = makeDeck(filter);

    if(deck.length === 0){
      idx = 0;
      stage = 0;
      els.hintText.textContent = "ï¼ˆãƒ’ãƒ³ãƒˆã¯ã“ã“ã«å‡ºã¾ã™ï¼‰";
      render();
      return;
    }

    if(prevId){
      const pos = deck.indexOf(prevId);
      if(pos >= 0){
        idx = pos;
      } else {
        // Aæ–¹å¼ï¼šæ¶ˆãˆãŸãªã‚‰ã€ŒåŒã˜ä½ç½®ã®æ¬¡ã€ã¸ï¼ˆ= idxç¶­æŒï¼‰ã€ãŸã ã—ç¯„å›²å†…ã«åã‚ã‚‹
        if(idx >= deck.length) idx = deck.length - 1;
      }
    } else {
      idx = 0;
    }

    stage = 0;
    els.hintText.textContent = "ï¼ˆãƒ’ãƒ³ãƒˆã¯ã“ã“ã«å‡ºã¾ã™ï¼‰";
    render();
  }

  function clampIndex(){
    if(deck.length === 0){
      idx = 0;
      return;
    }
    if(idx < 0) idx = 0;
    if(idx >= deck.length) idx = deck.length - 1;
  }

  function currentCard(){
    if(deck.length === 0) return null;
    clampIndex();
    return getCardById(deck[idx]);
  }

  function setStage(newStage){
    stage = Math.max(0, Math.min(2, newStage));
    els.hintText.textContent = "ï¼ˆãƒ’ãƒ³ãƒˆã¯ã“ã“ã«å‡ºã¾ã™ï¼‰";
    renderCard();
  }

  function stageName(){
    if(stage === 0) return "è¡¨";
    if(stage === 1) return "ã‚´ãƒ­";
    return "æ¼¢å­—";
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function filterLabel(filter){
    if(filter === "all") return "ã™ã¹ã¦";
    if(filter === "not") return "ã¾ã ï¼ˆnotï¼‰";
    return "ãŠã¼ãˆãŸï¼ˆlearnedï¼‰";
  }

  function render(){
    renderList();
    renderCard();
  }

  function renderCard(){
    const filter = currentFilter();
    els.filterNote.textContent = `ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼š${filterLabel(filter)}`;

    const c = currentCard();
    els.progressText.textContent = deck.length ? `${idx+1} / ${deck.length}` : `0 / 0`;
    els.stageLabel.textContent = stageName();

    els.prevBtn.disabled = (deck.length === 0 || idx === 0);
    els.nextBtn.disabled = (deck.length === 0 || idx === deck.length - 1);

    els.markNotBtn.classList.toggle("active", c?.status === "not");
    els.markLearnedBtn.classList.toggle("active", c?.status === "learned");

    if(!c){
      els.cardText.innerHTML = `
        <div class="cardText">
          <div class="frontText">ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“</div>
          <div class="small" style="margin-top:10px;">ã€Œï¼‹ è¿½åŠ /ç·¨é›†ã€ã¾ãŸã¯ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚</div>
        </div>
      `;
      els.flipBtn.disabled = true;
      els.hintBtn.disabled = true;
      els.markNotBtn.disabled = true;
      els.markLearnedBtn.disabled = true;
      els.resetStageBtn.disabled = true;
      els.hintText.textContent = "ï¼ˆãƒ’ãƒ³ãƒˆã¯ã“ã“ã«å‡ºã¾ã™ï¼‰";
      return;
    }

    els.flipBtn.disabled = false;
    els.hintBtn.disabled = false;
    els.markNotBtn.disabled = false;
    els.markLearnedBtn.disabled = false;
    els.resetStageBtn.disabled = false;

    if(stage === 0){
      els.cardText.innerHTML = `
        <div class="cardText">
          <div class="frontText">${escapeHtml(c.prompt) || "ï¼ˆè¡¨é¢ï¼‰"}</div>
        </div>
      `;
    } else if(stage === 1){
      els.cardText.innerHTML = `
        <div class="cardText">
          <div class="mnemonicText">${escapeHtml(c.mnemonic) || "ï¼ˆã‚´ãƒ­ï¼‰"}</div>
        </div>
      `;
    } else {
      els.cardText.innerHTML = `
        <div class="cardText">
          <div class="answerText">${escapeHtml(c.answer) || "ï¼ˆç­”ãˆï¼‰"}</div>
        </div>
      `;
    }
  }

  function renderList(){
    const sorted = [...cards].sort((a,b) => (b.updatedAt - a.updatedAt));
    els.cardList.innerHTML = "";
    if(sorted.length === 0){
      const div = document.createElement("div");
      div.className = "small";
      div.textContent = "ã¾ã ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å³ä¸Šã®ã€Œï¼‹ è¿½åŠ /ç·¨é›†ã€ã‹ã‚‰ä½œã‚Œã¾ã™ã€‚";
      els.cardList.appendChild(div);
      return;
    }

    const frag = document.createDocumentFragment();
    sorted.forEach((c) => {
      const item = document.createElement("div");
      item.className = "item";
      item.dataset.id = c.id;

      const badge = document.createElement("div");
      badge.className = "badge " + (c.status === "learned" ? "good" : "warn");
      badge.textContent = (c.status === "learned") ? "learned" : "not";

      const body = document.createElement("div");
      const title = document.createElement("div");
      title.className = "itemTitle";
      title.textContent = c.prompt || "ï¼ˆè¡¨é¢ãªã—ï¼‰";
      const sub = document.createElement("div");
      sub.className = "itemSub";
      sub.textContent = `ã‚´ãƒ­ï¼š${(c.mnemonic || "").slice(0, 18)}${(c.mnemonic || "").length > 18 ? "â€¦" : ""} ï¼ æ¼¢å­—ï¼š${c.answer || "â€”"}`;

      body.appendChild(title);
      body.appendChild(sub);

      item.appendChild(badge);
      item.appendChild(body);

      item.addEventListener("click", () => {
        // jump within current filter by switching filter if needed
        const filter = currentFilter();
        const wouldBeInDeck = (filter === "all") || (c.status === filter);
        if(!wouldBeInDeck){
          els.filterSelect.value = "all";
          rebuildDeck(false);
        } else {
          rebuildDeck(false);
        }
        const pos = deck.indexOf(c.id);
        if(pos >= 0){
          idx = pos;
          setStage(0);
          toast("ç§»å‹•ã—ã¾ã—ãŸ");
        }
      });

      frag.appendChild(item);
    });

    els.cardList.appendChild(frag);
  }

  function showHint(){
    const c = currentCard();
    if(!c) return;
    const t = (c.mnemonic || "").trim();
    if(!t){
      els.hintText.textContent = "ï¼ˆã‚´ãƒ­ãŒæœªå…¥åŠ›ã§ã™ï¼‰";
      return;
    }
    const hint = t.slice(0, 3);
    els.hintText.textContent = hint + (t.length > 3 ? "â€¦" : "");
  }

  function flipNextStage(){
    if(deck.length === 0) return;
    setStage(stage < 2 ? stage + 1 : 0);
  }

  function move(delta){
    if(deck.length === 0) return;

    if(pendingRebuild){
      // Apply filter cleanup now (the changed card may drop out of the deck).
      // After rebuildDeck(true), the "next" card (same index) will be shown automatically.
      pendingRebuild = false;
      rebuildDeck(true);

      // If user pressed "next", rebuild already moved off the filtered-out card -> done.
      if(delta > 0) return;

      // If user pressed "prev", go one step back from the new current card.
      idx -= 1;
      clampIndex();
      setStage(0);
      render();
      return;
    }

    idx += delta;
    clampIndex();
    setStage(0);
    render();
  }


  function shuffleDeck(){
    if(deck.length <= 1) return;
    for(let i = deck.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    idx = 0;
    stage = 0;
    render();
    toast("ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã—ãŸ");
  }

  function setStatus(status){
    const c = currentCard();
    if(!c) return;

    const filter = currentFilter();

    c.status = normalizeStatus(status);
    c.updatedAt = Date.now();
    saveCards();

    // IMPORTANT: Do NOT auto-advance. Keep showing the same card until user presses next/prev.
    // If this card becomes outside the current filter, we defer deck rebuild until navigation.
    pendingRebuild = (filter !== "all" && c.status !== filter);

    render(); // update button colors + list badges without changing idx/deck
  }

  // Editor state
  let editingId = null;

  function openEditorFor(id){
    const c = id ? getCardById(id) : null;
    editingId = c ? c.id : null;
    els.fPrompt.value = c?.prompt || "";
    els.fMnemonic.value = c?.mnemonic || "";
    els.fAnswer.value = c?.answer || "";
    els.deleteCardBtn.disabled = !c;
    els.editor.showModal();
  }

  function closeEditor(){
    if(els.editor.open) els.editor.close();
  }

  function saveEditor(){
    const prompt = els.fPrompt.value.trim();
    const mnemonic = els.fMnemonic.value.trim();
    const answer = els.fAnswer.value.trim();

    if(!prompt && !mnemonic && !answer){
      toast("ç©ºã®ã‚«ãƒ¼ãƒ‰ã¯ä¿å­˜ã§ãã¾ã›ã‚“");
      return;
    }

    if(editingId){
      const c = getCardById(editingId);
      if(!c){
        toast("ç·¨é›†å¯¾è±¡ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
        return;
      }
      c.prompt = prompt;
      c.mnemonic = mnemonic;
      c.answer = answer;
      c.updatedAt = Date.now();
    } else {
      cards.push({
        id: uid(),
        prompt, mnemonic, answer,
        status: "not",
        updatedAt: Date.now()
      });
    }

    saveCards();
    toast("ä¿å­˜ã—ã¾ã—ãŸ");
    rebuildDeck(false);
  }

  function deleteEditingCard(){
    if(!editingId) return;
    const ok = confirm("ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ");
    if(!ok) return;

    cards = cards.filter(x => x.id !== editingId);
    saveCards();
    editingId = null;
    toast("å‰Šé™¤ã—ã¾ã—ãŸ");
    rebuildDeck(false);
    closeEditor();
  }

  function exportJson(){
    const data = {
      version: 3,
      exportedAt: new Date().toISOString(),
      cards
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "kanji_flashcards_backup.json";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function importJson(){
    const inp = document.createElement("input");
    inp.type = "file";
    inp.accept = "application/json";
    inp.onchange = async () => {
      const file = inp.files?.[0];
      if(!file) return;
      try{
        const text = await file.text();
        const obj = JSON.parse(text);
        const incoming = Array.isArray(obj) ? obj : (obj.cards || []);
        if(!Array.isArray(incoming)) throw new Error("å½¢å¼ãŒé•ã„ã¾ã™");

        const cleaned = incoming.map(c => ({
          id: String(c.id ?? uid()),
          prompt: String(c.prompt ?? ""),
          mnemonic: String(c.mnemonic ?? ""),
          answer: String(c.answer ?? ""),
          status: normalizeStatus(c.status),
          updatedAt: Number(c.updatedAt ?? Date.now())
        })).filter(c => (c.prompt || c.mnemonic || c.answer));

        const ok = confirm(`ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¨ã€ä»Šã®ã‚«ãƒ¼ãƒ‰ã«ã€Œè¿½åŠ ã€ã•ã‚Œã¾ã™ï¼ˆ${cleaned.length}æšï¼‰ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ`);
        if(!ok) return;

        const map = new Map(cards.map(c => [c.id, c]));
        cleaned.forEach(c => map.set(c.id, c));
        cards = Array.from(map.values());
        saveCards();
        toast("ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ");
        rebuildDeck(false);
      }catch(e){
        alert("ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸï¼š " + e.message);
      }
    };
    inp.click();
  }

  // --- CSV helpers (quotes + commas supported)
  function parseCsv(text){
    const rows = [];
    let i = 0, field = "", row = [], inQuotes = false;
    const pushField = () => { row.push(field); field = ""; };
    const pushRow = () => { rows.push(row); row = []; };

    if(text.charCodeAt(0) === 0xFEFF) text = text.slice(1);

    while(i < text.length){
      const ch = text[i];

      if(inQuotes){
        if(ch === '"'){
          if(text[i+1] === '"'){ field += '"'; i += 2; continue; }
          inQuotes = false; i++; continue;
        }
        field += ch; i++; continue;
      } else {
        if(ch === '"'){ inQuotes = true; i++; continue; }
        if(ch === ','){ pushField(); i++; continue; }
        if(ch === '\r'){ i++; continue; }
        if(ch === '\n'){ pushField(); pushRow(); i++; continue; }
        field += ch; i++; continue;
      }
    }
    pushField();
    const isAllEmpty = row.every(v => String(v ?? "").trim() === "");
    if(!isAllEmpty) pushRow();
    return rows;
  }

  function toCsvValue(s){
    const v = String(s ?? "");
    if(v.includes('"') || v.includes(",") || v.includes("\n") || v.includes("\r")){
      return '"' + v.replaceAll('"','""') + '"';
    }
    return v;
  }

  function exportCsv(){
    const header = ["prompt","mnemonic","answer","status"];
    const lines = [header.join(",")];
    const sorted = [...cards].sort((a,b) => (b.updatedAt - a.updatedAt));
    sorted.forEach(c => {
      lines.push([
        toCsvValue(c.prompt),
        toCsvValue(c.mnemonic),
        toCsvValue(c.answer),
        toCsvValue(normalizeStatus(c.status))
      ].join(","));
    });
    const csvText = "\uFEFF" + lines.join("\n"); // BOM for Excel
    const blob = new Blob([csvText], {type:"text/csv;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "kanji_flashcards.csv";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function importCsv(){
    const inp = document.createElement("input");
    inp.type = "file";
    inp.accept = ".csv,text/csv";
    inp.onchange = async () => {
      const file = inp.files?.[0];
      if(!file) return;
      try{
        const text = await file.text();
        const rows = parseCsv(text);
        if(rows.length === 0) throw new Error("CSVãŒç©ºã§ã™");

        const header = rows[0].map(h => String(h || "").trim().toLowerCase());
        const idxPrompt = header.indexOf("prompt");
        const idxMnemonic = header.indexOf("mnemonic");
        const idxAnswer = header.indexOf("answer");
        const idxStatus = header.indexOf("status");

        if(idxPrompt < 0 || idxMnemonic < 0 || idxAnswer < 0){
          throw new Error("ãƒ˜ãƒƒãƒ€è¡Œã« prompt,mnemonic,answer ãŒå¿…è¦ã§ã™");
        }

        const cleaned = [];
        for(let r=1; r<rows.length; r++){
          const row = rows[r];
          const prompt = String(row[idxPrompt] ?? "").trim();
          const mnemonic = String(row[idxMnemonic] ?? "").trim();
          const answer = String(row[idxAnswer] ?? "").trim();
          const status = normalizeStatus(idxStatus >= 0 ? row[idxStatus] : "not");

          if(!prompt && !mnemonic && !answer) continue;
          cleaned.push({
            id: uid(),
            prompt, mnemonic, answer,
            status,
            updatedAt: Date.now()
          });
        }

        const ok = confirm(`CSVã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¨ã€ä»Šã®ã‚«ãƒ¼ãƒ‰ã«ã€Œè¿½åŠ ã€ã•ã‚Œã¾ã™ï¼ˆ${cleaned.length}æšï¼‰ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ`);
        if(!ok) return;

        cards = cards.concat(cleaned);
        saveCards();
        toast("CSVã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ");
        rebuildDeck(false);
      }catch(e){
        alert("CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸï¼š " + e.message);
      }
    };
    inp.click();
  }

  function seedExample(){
    const exists = cards.some(c => c.answer === "è¾²" || (c.prompt || "").includes("ãƒã‚¦"));
    if(exists){
      toast("ã™ã§ã«ä¾‹ãŒå…¥ã£ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“");
      return;
    }
    cards.push({
      id: uid(),
      prompt: "ãƒã‚¦æ¥­ã®ãƒã‚¦",
      mnemonic: "ã¾ãŒã£ãŸæ»‘ã‚Šå°ã«ãƒ¬ãƒ³ã‚³ãƒ³ãŒã¨ãŠã‚‹",
      answer: "è¾²",
      status: "not",
      updatedAt: Date.now()
    });
    saveCards();
    toast("ä¾‹ã‚’è¿½åŠ ã—ã¾ã—ãŸ");
    rebuildDeck(false);
  }

  function resetAllStatuses(){
    const ok = confirm("ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’ not ã«æˆ»ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ");
    if(!ok) return;
    cards.forEach(c => { c.status = "not"; c.updatedAt = Date.now(); });
    saveCards();
    toast("ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ");
    rebuildDeck(false);
  }

  function wipeAll(){
    const ok = confirm("å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ï¼ˆå–ã‚Šæ¶ˆã—ä¸å¯ï¼‰ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ");
    if(!ok) return;
    cards = [];
    localStorage.removeItem(LS_KEY);
    deck = [];
    idx = 0;
    stage = 0;
    toast("å‰Šé™¤ã—ã¾ã—ãŸ");
    render();
  }

  function doExport(){
    const t = els.ioType.value;
    if(t === "csv") exportCsv();
    else exportJson();
  }

  function doImport(){
    const t = els.ioType.value;
    if(t === "csv") importCsv();
    else importJson();
  }

  // --- Events
  els.hintBtn.addEventListener("click", showHint);
  els.flipBtn.addEventListener("click", flipNextStage);
  els.prevBtn.addEventListener("click", () => move(-1));
  els.nextBtn.addEventListener("click", () => move(1));
  els.resetStageBtn.addEventListener("click", () => setStage(0));
  els.shuffleBtn.addEventListener("click", shuffleDeck);

  els.markNotBtn.addEventListener("click", () => setStatus("not"));
  els.markLearnedBtn.addEventListener("click", () => setStatus("learned"));

  els.filterSelect.addEventListener("change", () => {
    idx = 0;
    stage = 0;
    rebuildDeck(false);
  });

  els.addBtn.addEventListener("click", () => openEditorFor(currentCard()?.id || null));

  els.exportBtn.addEventListener("click", doExport);
  els.importBtn.addEventListener("click", doImport);

  els.resetAllBtn.addEventListener("click", resetAllStatuses);
  els.wipeBtn.addEventListener("click", wipeAll);

  els.closeEditorBtn.addEventListener("click", closeEditor);
  els.closeEditorBtn2.addEventListener("click", closeEditor);
  els.saveCardBtn.addEventListener("click", saveEditor);
  els.newCardBtn.addEventListener("click", () => openEditorFor(null));
  els.deleteCardBtn.addEventListener("click", deleteEditingCard);
  els.seedBtn.addEventListener("click", seedExample);

  // Keyboard shortcuts
  document.addEventListener("keydown", (e) => {
    if(els.editor.open) return;
    const key = e.key.toLowerCase();
    if(key === " "){
      e.preventDefault();
      flipNextStage();
    } else if(key === "h"){
      showHint();
    } else if(key === "j"){
      setStatus("not");
    } else if(key === "k"){
      setStatus("learned");
    } else if(key === "arrowright"){
      move(1);
    } else if(key === "arrowleft"){
      move(-1);
    }
  });

  // initial (STUDENT MODE: always fetch CSV and overwrite localStorage)
  els.filterSelect.value = "all";

  async function bootstrapStudentMode(){
    const cfg = getStudentConfig();

    try{
      // show loading message
      els.cardText.innerHTML = `
        <div class="cardText">
          <div class="frontText">ã‚ˆã¿ã“ã¿ä¸­â€¦</div>
          <div class="small" style="margin-top:10px;">${escapeHtml(cfg.csv)} ã‚’ã‚ˆã¿ã“ã‚“ã§ã„ã¾ã™</div>
        </div>
      `;
      els.flipBtn.disabled = true;
      els.hintBtn.disabled = true;
      els.markNotBtn.disabled = true;
      els.markLearnedBtn.disabled = true;
      els.resetStageBtn.disabled = true;

      const res = await fetch(cfg.csv, { cache: "no-store" });
      if(!res.ok) throw new Error(`fetch ã—ã£ã±ã„: ${res.status}`);
      const text = await res.text();

      const rows = parseCsv(text);
      if(rows.length === 0) throw new Error("CSV ãŒã‹ã‚‰ã§ã™");

      const header = rows[0].map(h => String(h || "").trim().toLowerCase());
      const idxPrompt = header.indexOf("prompt");
      const idxMnemonic = header.indexOf("mnemonic");
      const idxAnswer = header.indexOf("answer");
      const idxStatus = header.indexOf("status");

      if(idxPrompt < 0 || idxMnemonic < 0 || idxAnswer < 0){
        throw new Error("ãƒ˜ãƒƒãƒ€è¡Œã« prompt,mnemonic,answer ãŒã²ã¤ã‚ˆã†ã§ã™");
      }

      const loaded = [];
      let rowIndex = 0;
      for(let r=1; r<rows.length; r++){
        const row = rows[r];
        const prompt = String(row[idxPrompt] ?? "").trim();
        const mnemonic = String(row[idxMnemonic] ?? "").trim();
        const answer = String(row[idxAnswer] ?? "").trim();
        const status = normalizeStatus(idxStatus >= 0 ? row[idxStatus] : "not");

        if(!prompt && !mnemonic && !answer) continue;

        loaded.push({
          id: stableIdFromRow(rowIndex++),
          prompt, mnemonic, answer,
          status,
          updatedAt: Date.now()
        });
      }

      cards = loaded;

      // MUST overwrite localStorage every startup
      saveCards();

      // reset runtime state
      deck = [];
      idx = 0;
      stage = 0;
      rebuildDeck(false);
      toast("ã‚ˆã¿ã“ã¿ ã‹ã‚“ã‚Šã‚‡ã†");
    }catch(e){
      console.warn(e);
      cards = [];
      // overwrite to avoid stale student progress
      saveCards();

      deck = [];
      idx = 0;
      stage = 0;
      render();

      els.cardText.innerHTML = `
        <div class="cardText">
          <div class="frontText">CSV ãŒã‚ˆã¿ã“ã‚ã¾ã›ã‚“</div>
          <div class="small" style="margin-top:10px;">${escapeHtml(String(e.message || e))}</div>
          <div class="small" style="margin-top:6px;">URL ã® csv= ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚ã„ ã¨ã€CSV ã®ã°ã—ã‚‡ã‚’ ã‹ãã«ã‚“ã—ã¦ãã ã•ã„</div>
        </div>
      `;
    }
  }

  bootstrapStudentMode();

// add a quick seed button only via editor footer (kept)
  // if you want an immediate sample without opening editor, uncomment:
  // seedExample();

})();
</script>
</body>
</html>
